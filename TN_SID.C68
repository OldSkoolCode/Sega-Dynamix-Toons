/* * * * *
*
*  TN_SID.C
*
*  This module contains code associated with the Sid mouse character of toons.
*  It does not contain the data structures defining the artwork of the
*  character.
*
*  By Chris Cole -- (c) 1993 Dynamix Software Development, Inc.
*
*  Modification History:
*  ---------------------
*  05/15/93 ChrisC   File created
*
* * * * */
#include "vm.h"
#include "tim.h"
#include "simlib.h"



/* * * * *
*
*  local function to this module
*
* * * * */
char preempt_mouse(PART *mouse);
short mouse_observation(PART *mouse);
short mouse_query_switch(PART *mouse, PART *pptr);
void mouse_root(PART *mouse);
void mouse_take(PART *mouse);
void mouse_run(PART *mouse);
void mouse_giggle(PART *mouse);
void mouse_bronx(PART *mouse);
void mouse_fall(PART *mouse);
void mouse_splat(PART *mouse);
void mouse_wait(PART *mouse);
void mouse_hair(PART *mouse);
void mouse_cut(PART *mouse);
void mouse_whop(PART *mouse);
void mouse_climb(PART *mouse);
void mouse_walk(PART *mouse);
void mouse_gun(PART *mouse);
void mouse_dustb(PART *mouse);
void mouse_butt(PART *mouse);
void mouse_bonk(PART *mouse);
void mouse_anvil(PART *mouse);
void mouse_cheese(PART *mouse);
void mouse_lunch(PART *mouse);
void mouse_piano(PART *mouse);
void mouse_hit_floor(PART *mouse);
void mouse_hit_ceiling(PART *mouse);
void mouse_hit_left_wall(PART *mouse);
void mouse_hit_right_wall(PART *mouse);
void mouse_fly_up(PART *mouse);
void mouse_bomb(PART *mouse);
void mouse_shake(PART *mouse);
void mouse_dragon(PART *mouse);
void mouse_hdryr(PART *mouse);
void mouse_gum(PART *mouse);
void mouse_wait1(PART *mouse);
void mouse_wait2(PART *mouse);
void mouse_wait3(PART *mouse);
void mouse_wait4(PART *mouse);
void mouse_random_wait(PART *mouse);
void mouse_stop(PART *mouse);
void mouse_pin1(PART *mouse);
void mouse_pin2(PART *mouse);
void mouse_slide1(PART *mouse);
void mouse_slide2(PART *mouse);
void mouse_slide3(PART *mouse);
void mouse_slide4(PART *mouse);
void mouse_vac(PART *mouse);
void mouse_vac2(PART *mouse);
void mouse_vac3(PART *mouse);
void mouse_tunnel(PART *mouse);
void mouse_pencil1(PART *mouse);
void mouse_pencil2(PART *mouse);
void mouse_pencil3(PART *mouse);
void mouse_pencil4(PART *mouse);
void mouse_headless(PART *mouse);
void mouse_peel(PART *mouse);
void mouse_banana(PART *mouse);
void mouse_bubble(PART *mouse);
void mouse_bubble2(PART *mouse);
void mouse_egg(PART *mouse);

/* Define data tables that help make the code smaller */
struct mouse_tables
{
   short index2seq;
   void (* mouse_func) (PART *);
} far const mouse_tables[CAT_NUM_STATES] =
{
   SID_ROOT_SEQ,                    mouse_root,
  -SID_TAKE_SEQ,                    mouse_take,
   SID_RUN_SEQ,                     mouse_run,
  -SID_GIGGLE_SEQ,                  mouse_giggle,
  -SID_BRONX_SEQ,                   mouse_bronx,
   SID_FALL_SEQ,                    mouse_fall,
   SID_SPLAT_SEQ,                   mouse_splat,
   SID_WAIT_SEQ,                    mouse_wait,
   SID_HAIR_SEQ,                    mouse_hair,
  -SID_CUT_SEQ,                     mouse_cut,
   SID_WHOP_SEQ,                    mouse_whop,
  -SID_CLIMB_SEQ,                   mouse_climb,
   SID_WALK_SEQ,                    mouse_walk,
   SID_GUN_SEQ,                     mouse_gun,
   SID_DUSTB_SEQ,                   mouse_dustb,
   SID_BUTT_SEQ,                    mouse_butt,
   SID_BONK_SEQ,                    mouse_bonk,
   SID_ANVIL_SEQ,                   mouse_anvil,
   SID_CHEESE_SEQ,                  mouse_cheese,
   SID_LUNCH_SEQ,                   mouse_lunch,
  -SID_PIANO_SEQ,                   mouse_piano,
   SID_HIT_FLOOR_SEQ,               mouse_hit_floor,
   SID_HIT_CEILING_SEQ,             mouse_hit_ceiling,
   SID_HIT_LEFT_WALL_SEQ,           mouse_hit_left_wall,
   SID_HIT_RIGHT_WALL_SEQ,          mouse_hit_right_wall,
   SID_FLY_UP_SEQ,                  mouse_fly_up,
   SID_BOMB_SEQ,                    mouse_bomb,
   SID_SHAKE_SEQ,                   mouse_shake,
   SID_DRAGON_SEQ,                  mouse_dragon,
   SID_HDRYR_SEQ,                   mouse_hdryr,
   SID_GUM_SEQ,                     mouse_gum,
   SID_WAIT1_SEQ,                   mouse_wait1,
   SID_WAIT2_SEQ,                   mouse_wait2,
   SID_WAIT3_SEQ,                   mouse_wait3,
   SID_WAIT4_SEQ,                   mouse_wait4,
   SID_STOP_SEQ,                    mouse_stop,
   SID_PIN1_SEQ,                    mouse_pin1,
   SID_PIN2_SEQ,                    mouse_pin2,
   SID_SLIDE1_SEQ,                  mouse_slide1,
   SID_SLIDE2_SEQ,                  mouse_slide2,
   SID_SLIDE3_SEQ,                  mouse_slide3,
   SID_SLIDE4_SEQ,                  mouse_slide4,
   SID_VAC_SEQ,                     mouse_vac,
   SID_VAC2_SEQ,                    mouse_vac2,
   SID_VAC3_SEQ,                    mouse_vac3,
   SID_TUNNEL_SEQ,                  mouse_tunnel,
   SID_PENCIL1_SEQ,                 mouse_pencil1,
   SID_PENCIL2_SEQ,                 mouse_pencil2,
   SID_PENCIL3_SEQ,                 mouse_pencil3,
   SID_PENCIL4_SEQ,                 mouse_pencil4,
   SID_PEEL_SEQ,                    mouse_peel,
   SID_HEADLESS_SEQ,                mouse_headless,
   SID_BANANA_SEQ,                  mouse_banana,
   SID_BUBBLE_SEQ,                  mouse_bubble,
   SID_BUBBLE2_SEQ,                 mouse_bubble2,
   SID_EGG_SEQ,                     mouse_egg,
   SID_NUM_STATES,                  0
};

/* * * * *
*
*  mouse global and local variables and defines.
*
* * * * */
CHAR mouse_bord_num;

#define MOUSE_FALLING            SIX_PIX
#define SID_FALL_THRESHOLD1      FOUR_PIX
#define SID_FALL_THRESHOLD2      FIVE_PIX
#define SID_FALL_THRESHOLD3      TEN_PIX
#define SID_FALL_THRESHOLD4      (SIXTEEN_PIX + TWO_PIX)
#define SID_SHIFT                8
#define TAKE_TIME                60
#define GIGGLE_TIME              60
#define BRONX_TIME               60
#define MOUSE_GUM_FLOAT_STATE    (17 + SID_GUM_SEQ)

/* * * * *
*
*  void mouse_reinit(PART *mouse);
*
*  This function will reinitiallize the borders of the mouse character.
*
* * * * */
void mouse_reinit(PART *mouse)
{
   /* If initalizing for the first time, create flip borders */
   if(!mouse)
   {
      set_border_slopes(PT_SID_MOUSE, 0, mouse_root_border, 0, 0);
      return;
   }

   mouse->border = mouse_root_border;
   set_adjusted_loc_size(mouse);
}

/* * * * *
*
*  void sid_flip(PART *mouse, SHORT flip_mode);
*
* * * * */
#pragma argsused
void sid_flip(PART *mouse, SHORT flip_mode)
{
   mouse->flags2 ^= F2_FLIP_H_DRAW;
   mouse_reinit(mouse);
   part_to_er(mouse,1|2);
   set_redraw(mouse,2);
}

/* * * * *
*
*  short mouse_collide(PART *cur_part);
*
*  This is the main collision rountine.
*
* * * * */
short mouse_collide(PART *cur_part)
{
   PART *mouse, *toon_link;
   short slope,speed_x,speed_y,old_speed_y;
   short mouse_mid_x, part_mid_x;
   short mouse_mid_y, part_mid_y;

   /* assigns the pointers to the correct parts. */
   if (cur_part->type == PT_SID_MOUSE)
   {
      mouse = cur_part;
      cur_part = cur_part->col_info.part;
      slope = mouse->col_info.slope;
   }
   else
   {
      mouse = cur_part->col_info.part;
      slope = cur_part->col_info.slope;
   }
   
   /* calculate the relative speeds of the two colliding parts. */
   speed_x = mouse->speed.x - cur_part->speed.x;
   speed_y = mouse->speed.y - cur_part->speed.y;
   old_speed_y = mouse->speed.y;

   /* calculate the midpoints of the two parts */
   mouse_mid_x = mouse->scrn_loc.x + (mouse->base_size.x >> 1);
   mouse_mid_y = mouse->scrn_loc.y + (mouse->base_size.y >> 1);
   part_mid_x = cur_part->scrn_loc.x + (cur_part->base_size.x >> 1);
   part_mid_y = cur_part->scrn_loc.y + (cur_part->base_size.y >> 1);

   /* special check to see if the mouse is supported on the end of wall */
/*   if (  !slope */
/*      && (mouse->flags1 & F1_ROLLING) */
/*      && (abs(speed_x) < ONE_PIX)) */
/*      mouse->speed.x = 0; */

   /* check for hitting cases */
   if (  (mouse->sub_state == -1)
      && !(mouse->flags1 & F1_ROLLING))
   {
      switch (slope)
      {
         case 0x0000:
            if (speed_y > SID_FALL_THRESHOLD2)
               mouse->sub_state = SID_HIT_FLOOR_INDEX;
            break;
         case -0x8000:
            if (speed_y < -SID_FALL_THRESHOLD1)
               mouse->sub_state = SID_HIT_CEILING_INDEX;
            break;
         case 0x4000:
            if (speed_x > TWO_PIX)
            {
               if (mouse->flags2 & F2_FLIP_H_DRAW)
                  mouse->sub_state = SID_HIT_LEFT_WALL_INDEX;
               else
                  mouse->sub_state = SID_HIT_RIGHT_WALL_INDEX;
            }
            break;
         case -0x4000:
            if (speed_x < -TWO_PIX)
            {
               if (mouse->flags2 & F2_FLIP_H_DRAW)
                  mouse->sub_state = SID_HIT_RIGHT_WALL_INDEX;
               else
                  mouse->sub_state = SID_HIT_LEFT_WALL_INDEX;
            }
            break;
      }
   }
   
   switch (mouse->toon_state)
   {
      case SID_RUN_INDEX:
         switch (slope)
         {
            case 0x4000:
               if (mouse->flags2 & F2_FLIP_H_DRAW)
                  mouse->sub_state = SID_HIT_LEFT_WALL_INDEX;
               else
                  mouse->sub_state = SID_HIT_RIGHT_WALL_INDEX;
               break;
            case -0x4000:
               if (mouse->flags2 & F2_FLIP_H_DRAW)
                  mouse->sub_state = SID_HIT_RIGHT_WALL_INDEX;
               else
                  mouse->sub_state = SID_HIT_LEFT_WALL_INDEX;
               break;
         }
         goto SID_CHECK_PART_COLLISION;
      case SID_WALK_INDEX:
         if ((slope == 0x4000) || (slope == -0x4000))
         {
            mouse->sub_state = SID_ROOT_INDEX;
            mouse->speed.x = 0;
         }
         goto SID_CHECK_PART_COLLISION;
      case SID_FALL_INDEX:
      case SID_BUTT_INDEX:
         if (mouse->sub_state == -1)
            mouse->sub_state = SID_ROOT_INDEX;
         goto SID_CHECK_PART_COLLISION;
      case SID_GUM_INDEX:
         /* check if sid is floating up with the gum. */
         if (mouse->state == MOUSE_GUM_FLOAT_STATE)
         {
            /* make sure nothing improper will change the state of the mouse */
            mouse->sub_state = -1;

            switch (cur_part->type)
            {
               case PT_HATPIN:
                  /* check the hatpin is vertically orientated */
                  if (!cur_part->state)
                  {
                     /* check if the hatpin is oriented with the tip down */
                     if (cur_part->flags2 & F2_FLIP_V_DRAW)
                     {
                        if (mouse_mid_y > part_mid_y)
                           mouse->sub_state = SID_BUBBLE_INDEX;
                     }
                     else
                     {
                        if (mouse_mid_y < part_mid_y)
                           mouse->sub_state = SID_BUBBLE_INDEX;
                     }
                  }
                  else
                  {
                     /* check if the hatpin is oriented with the tip left */
                     if (cur_part->flags2 & F2_FLIP_H_DRAW)
                     {
                        if (mouse_mid_x < part_mid_x)
                           mouse->sub_state = SID_BUBBLE_INDEX;
                     }
                     else
                     {
                        if (mouse_mid_x > part_mid_x)
                           mouse->sub_state = SID_BUBBLE_INDEX;
                     }
                  }
                  break;
               case PT_GEAR:
                  /* check if the gear is moving */
                  if (cur_part->state != cur_part->old_state)
                     mouse->sub_state = SID_BUBBLE_INDEX;
                  break;
               case PT_SCISSORS:
                  /* check if the scissors is facing left */
                  if (cur_part->flags2 & F2_FLIP_H_DRAW)
                  {
                     if (mouse_mid_x > part_mid_x)
                        mouse->sub_state = SID_BUBBLE_INDEX;
                  }
                  else
                  {
                     if (mouse_mid_x < part_mid_x)
                        mouse->sub_state = SID_BUBBLE_INDEX;
                  }
                  break;
               case PT_BULLET:
                  mouse->sub_state = SID_BUBBLE_INDEX;
                  break;
            }
         }
         break;
      case SID_BUBBLE_INDEX:
         mouse->sub_state = SID_BUBBLE2_INDEX;
         break;
      case SID_SLIDE1_INDEX:
      case SID_SLIDE2_INDEX:
      case SID_SLIDE3_INDEX:
      case SID_SLIDE4_INDEX:
         switch (cur_part->type)
         {
            case PT_INCLINE1:
            case PT_INCLINE2:
            case PT_INCLINE3:
            case PT_INCLINE4:
            case PT_INCLINE5:
               break;
            default:
               if (mouse->sub_state == -1)
                  mouse->sub_state = SID_ROOT_INDEX;
         }
         goto SID_CHECK_PART_COLLISION;
      default:
SID_CHECK_PART_COLLISION:
         mouse->speed.y = 0;
         switch (cur_part->type)
         {
            case PT_AL_CAT:
               /* force the collision between the two characters to go through */
               /* the same function. */
               character_collision(cur_part,mouse);
               break;
            case PT_HAIR_BALL:          
               mouse->sub_state = SID_HAIR_INDEX;
               break;
            case PT_BULLET:          
               mouse->sub_state = SID_GUN_INDEX;
               break;
            case PT_DUSTBUNNY:
               if (preempt_mouse(mouse))
               {
                  mouse->toon_link = cur_part;
                  mouse->sub_state = SID_DUSTB_INDEX;
               }
               break;
            case PT_HATPIN:
               /* check if the hatpin is oriented vertically */
               if (!cur_part->state)
               {
                  /* check if the mouse hit the tip of the pin */
                  if (!(cur_part->flags2 & F2_FLIP_V_DRAW))
                  {
                     if (mouse_mid_y < part_mid_y)
                     {
                        mouse->speed.x = mouse->speed.y = 0;
                        mouse->sub_state = SID_PIN1_INDEX;
                     }
                  }
                  else
                  {
                     if (mouse_mid_y > part_mid_y)
                     {
                        mouse->speed.x = mouse->speed.y = 0;
                        mouse->sub_state = SID_PIN2_INDEX;
                     }
                  }
               }
               else
               {
                  /* check if the mouse hit the right tip of the pin */
                  if (!(cur_part->flags2 & F2_FLIP_H_DRAW))
                  {
                     if (mouse_mid_x > part_mid_x)
                     {
                        if (!(mouse->flags2 & F2_FLIP_H_DRAW))
                           sid_flip(mouse, F2_FLIP_H_DRAW);
                        mouse->speed.x = mouse->speed.y = 0;
                        mouse->sub_state = SID_BUTT_INDEX;
                     }
                  }
                  else
                  {
                     if (mouse_mid_x < part_mid_x)
                     {
                        if (mouse->flags2 & F2_FLIP_H_DRAW)
                           sid_flip(mouse, F2_FLIP_H_DRAW);
                        mouse->speed.x = mouse->speed.y = 0;
                        mouse->sub_state = SID_BUTT_INDEX;
                     }
                  }
               }
               break;
            case PT_YARNBALL:          
            case PT_BASEBALL:          
            case PT_SOCCER:          
               if (abs(speed_y) > SID_FALL_THRESHOLD2)
                  mouse->sub_state = SID_BONK_INDEX;
               break;
            case PT_ANVIL:          
            case PT_TEAPOT:          
            case PT_BOMB:          
            case PT_ROCK:          
               if (abs(speed_y) > SID_FALL_THRESHOLD2)
                  mouse->sub_state = SID_ANVIL_INDEX;
               break;
            case PT_GUM:          
               if (  (abs(cur_part->speed.y >> SCALE_SHIFT) < 1)
                  && preempt_mouse(mouse))
               {
                  mouse->sub_state = SID_GUM_INDEX;
                  mouse->toon_link = cur_part;
               }
               break;
            case PT_SCISSORS:
               /* check if the scissors are in the correct orientation to sid */
               /* so he can use them */
               if (  (((mouse_mid_x > part_mid_x)
                  && !(mouse->flags2 & F2_FLIP_H_DRAW)
                  && !(cur_part->flags2 & F2_FLIP_H_DRAW))
                  || ((mouse_mid_x < part_mid_x)
                  && (mouse->flags2 & F2_FLIP_H_DRAW)
                  && (cur_part->flags2 & F2_FLIP_H_DRAW)))
                  && !cur_part->state
                  && preempt_mouse(mouse))
               {
                  mouse->sub_state = SID_CUT_INDEX;
                  mouse->toon_link = cur_part;
               }

               /* check if the scissors are in the correct orientation to sid */
               /* so he gets stuck by them */
               else if (  (mouse_mid_x > part_mid_x)
                  && (cur_part->flags2 & F2_FLIP_H_DRAW))
               {
                  if (!(mouse->flags2 & F2_FLIP_H_DRAW))
                     sid_flip(mouse, F2_FLIP_H_DRAW);
                  mouse->sub_state = SID_BUTT_INDEX;
               }

               /* check if the scissors are in the correct orientation to sid */
               /* so he gets stuck by them */
               else if (  (mouse_mid_x < part_mid_x)
                  && !(cur_part->flags2 & F2_FLIP_H_DRAW))
               {
                  if (mouse->flags2 & F2_FLIP_H_DRAW)
                     sid_flip(mouse, F2_FLIP_H_DRAW);
                  mouse->sub_state = SID_BUTT_INDEX;
               }
               break;
            case PT_PIANO:
               /* check if the piano is falling and hitting sid */
               if (cur_part->sub_state
                  && preempt_mouse(mouse)
                  && (cur_part->speed.y > 0)
                  && (mouse_mid_y > part_mid_y)
                  && (mouse_mid_x > part_mid_x - 25)
                  && (mouse_mid_x < part_mid_x + 25))
               {
                  mouse->sub_state = SID_PIANO_INDEX;
                  mouse->toon_link = cur_part;
               }
               break;
            case PT_CHEESE:          
               if (preempt_mouse(mouse))
               {
                  mouse->sub_state = SID_CHEESE_INDEX;
                  mouse->toon_link = cur_part;
               }
               break;
            case PT_PENCIL:
               if (preempt_mouse(mouse))
               {
                  /* check if the mouse is being chased by the cat */
                  if (((toon_link = mouse->toon_link) != 0) &&
                     (toon_link->type == PT_AL_CAT))
                  {
                     switch (toon_link->toon_state)
                     {
                        case CAT_RUN_INDEX:
                           toon_link->sub_state = CAT_STOP_INDEX;
                           break;
                        case CAT_SPIN_INDEX:
                           toon_link->sub_state = CAT_SHAKE_INDEX;
                     }
                  }

                  mouse->sub_state = SID_PENCIL1_INDEX;
                  mouse->toon_link = cur_part;
               }
               break;
            case PT_TRAMP:
               mouse->speed.y = old_speed_y;
               mouse->sub_state = SID_FLY_UP_INDEX;
               break;
            case PT_INCLINE0:       
            case PT_INCLINE1:       
            case PT_INCLINE2:      
            case PT_INCLINE3:       
            case PT_INCLINE4:
            case PT_INCLINE5:
               /* check if the mouse hit the incline from above */
               if (  preempt_mouse(mouse)
                  && (old_speed_y > 0)
                  && (mouse->scrn_loc.y < cur_part->scrn_loc.y)
                  && ((!(cur_part->flags2 & F2_FLIP_H_DRAW)
                  && mouse->col_info.left_of_cog_supported)
                  || ((cur_part->flags2 & F2_FLIP_H_DRAW)
                  && mouse->col_info.right_of_cog_supported)))
               {
                  /* reset the vertical speed of the mouse */
                  mouse->speed.y = old_speed_y;

                  /* remember which incline was hit */
                  mouse->toon_link = cur_part;

                  /* decide which slide to use. */
                  switch (cur_part->state)
                  {
                     case 3:
                        mouse->sub_state = SID_SLIDE1_INDEX;
                        break;
                     case 2:
                        mouse->sub_state = SID_SLIDE2_INDEX;
                        break;
                     case 1:
                        mouse->sub_state = SID_SLIDE3_INDEX;
                        break;
                     case 0:
                        mouse->sub_state = SID_SLIDE4_INDEX;
                        break;
                  }
               }
               else
                  /* This allows for the richochette off the inclines */
                  mouse->speed.y = old_speed_y;
               break;
            case PT_BANANA:
               if (preempt_mouse(mouse))
               {
                  if (cur_part->state == BANANA_PEEL)
                  {
                     mouse->sub_state = SID_PEEL_INDEX;
                     mouse->toon_link = cur_part;
                  }
                  else
                  {
                     mouse->sub_state = SID_BANANA_INDEX;
                     mouse->toon_link = cur_part;
                  }
               }
               break;
            case PT_EGG:
               if (  preempt_mouse(mouse)
                  && (speed_y < -EGG_THRESHOLD))
               {
                  mouse->sub_state = SID_EGG_INDEX;
                  mouse->toon_link = cur_part;
               }
               break;
         }
         break;
   }

   return(1);
}



/* * * * *
*
*  void mouse_internal(PART *mouse);
*
* * * * */
void mouse_internal(PART *mouse)
{
   short temp, old_state;
   PART *toon_link;

   /* If internal function has already been processed, just return */
   if(mouse->flags2 & F2_INTERNAL)
      return;
   mouse->flags2 |= F2_INTERNAL;

   /* If rolling and falling at the same time, adjust fall speed */
   if((mouse->speed.y >= MOUSE_FALLING) && (mouse->flags1 & F1_ROLLING))
      mouse->speed.y = MOUSE_FALLING - 1;

   /* process collision */
   if (  preempt_mouse(mouse)
      && (mouse->sub_state >= 0)
      && (mouse->sub_state != mouse->toon_state))
   {
      old_state = mouse->state;
      switch (mouse->sub_state)
      {
         case SID_TAKE_INDEX:
            if ((mouse->work_var1 >> SID_SHIFT) != SID_TAKE_INDEX)
            {
               mouse->speed.x = 0;
               mouse->state = SID_TAKE_SEQ;
               mouse->work_var1 = TAKE_TIME + (SID_TAKE_INDEX << SID_SHIFT);
            }
            break;
         case SID_GIGGLE_INDEX:
            if ((mouse->work_var1 >> SID_SHIFT) != SID_GIGGLE_INDEX)
            {
               mouse->speed.x = 0;
               mouse->state = SID_GIGGLE_SEQ;
               mouse->work_var1 = GIGGLE_TIME+(SID_GIGGLE_INDEX << SID_SHIFT);
            }
            break;
         case SID_BRONX_INDEX:
            if ((mouse->work_var1 >> SID_SHIFT) != SID_BRONX_INDEX)
            {
               mouse->speed.x = 0;
               mouse->state = SID_BRONX_SEQ;
               mouse->work_var1 = BRONX_TIME + (SID_BRONX_INDEX << SID_SHIFT);
            }
            break;
         case SID_CUT_INDEX:
            /* check if the toon link is still o.k. */
            if (((toon_link = mouse->toon_link) != 0) &&
               (mouse->toon_link->type == PT_SCISSORS))
            {
               /* repositions the mouse to be in the correct location. */
               if (!(mouse->flags2 & F2_FLIP_H_DRAW))
               {
                  mouse->loc.x = mouse->old_scrn_loc.x =
                     mouse->scrn_loc.x = toon_link->scrn_loc.x + 38;
                  mouse->loc.y = mouse->old_scrn_loc.y =
                     mouse->scrn_loc.y = toon_link->scrn_loc.y + 1;
               }
               else
               {
                  mouse->loc.x = mouse->old_scrn_loc.x =
                     mouse->scrn_loc.x = toon_link->scrn_loc.x - 22;
                  mouse->loc.y = mouse->old_scrn_loc.y =
                     mouse->scrn_loc.y = toon_link->scrn_loc.y + 1;
               }
               mouse->loc.x <<= SCALE_SHIFT;
               mouse->loc.y <<= SCALE_SHIFT;

               mouse->state = SID_CUT_SEQ;
            }
            break;
         case SID_CLIMB_INDEX:
            if ((mouse->work_var1 >> EIGHT_BITS) != SID_CLIMB_INDEX)
            {
               /* reposition mouse on ladder. */
               if (mouse->flags2 & F2_FLIP_H_DRAW)
                  mouse->scrn_loc.x = mouse->old_scrn_loc.x = mouse->loc.x =
                     mouse->toon_link->scrn_loc.x +
                     mouse->toon_link->base_size.x -
                     mouse->base_size.x;
               else
                  mouse->scrn_loc.x = mouse->old_scrn_loc.x = mouse->loc.x =
                     mouse->toon_link->scrn_loc.x;
               mouse->loc.x <<= SCALE_SHIFT;
               character_from_move_to_static(mouse);
               
               init_part_ladder(mouse,SID_RUN_INDEX, SID_CLIMB_SEQ,
                  SID_ROOT_INDEX, SID_ROOT_SEQ);
            }
            break;
         case SID_PIANO_INDEX:
            /* check if the toon link is still o.k. */
            if (((toon_link = mouse->toon_link) != 0) &&
               (mouse->toon_link->type == PT_PIANO))
            {
               character_from_move_to_static(mouse);
               mouse->state = SID_PIANO_SEQ;
            }
            break;
         case SID_GUM_INDEX:
            /* orient the mouse to face the gum */
            if (((toon_link = mouse->toon_link) != 0) &&
               (toon_link->type == PT_GUM) &&
               (((mouse->flags2 & F2_FLIP_H_DRAW) &&
               (mouse->scrn_loc.x > mouse->toon_link->scrn_loc.x)) ||
               (!(mouse->flags2 & F2_FLIP_H_DRAW) &&
               (mouse->scrn_loc.x < mouse->toon_link->scrn_loc.x))))
               sid_flip(mouse, F2_FLIP_H_DRAW);
            break;
         case SID_SLIDE1_INDEX:
         case SID_SLIDE2_INDEX:
         case SID_SLIDE3_INDEX:
         case SID_SLIDE4_INDEX:
            /* decide if the toon_link is still good */
            if (((toon_link = mouse->toon_link) != 0) &&
               (toon_link->type >= PT_INCLINE0) &&
               (toon_link->type <= PT_INCLINE5))
            {
               /* check the orientation of the mouse to the toon_linked incline */
               if (!(toon_link->flags2 & F2_FLIP_H_DRAW))
               {
                  if (!(mouse->flags2 & F2_FLIP_H_DRAW))
                     sid_flip(mouse, F2_FLIP_H_DRAW);
               }
               else
               {
                  if (mouse->flags2 & F2_FLIP_H_DRAW)
                     sid_flip(mouse, F2_FLIP_H_DRAW);
               }
            }
            break;
         case SID_BUTT_INDEX:
         case SID_BONK_INDEX:
         case SID_ANVIL_INDEX:
         case SID_CHEESE_INDEX:
         case SID_LUNCH_INDEX:
         case SID_HIT_FLOOR_INDEX:
         case SID_HIT_CEILING_INDEX:
         case SID_HIT_LEFT_WALL_INDEX:
         case SID_HIT_RIGHT_WALL_INDEX:
         case SID_SHAKE_INDEX:
         case SID_DRAGON_INDEX:
         case SID_STOP_INDEX:
         case SID_PIN1_INDEX:
         case SID_PIN2_INDEX:
         case SID_PENCIL4_INDEX:
         case SID_PEEL_INDEX:
         case SID_BANANA_INDEX:
         case SID_BUBBLE_INDEX:
         case SID_BUBBLE2_INDEX:
         case SID_EGG_INDEX:
            mouse->speed.x = mouse->speed.y = 0;
            break;
      }
      
      /* Convert index to a sequence */
      if(mouse_tables[mouse->sub_state].index2seq >= 0)
         mouse->state = mouse_tables[mouse->sub_state].index2seq;

      /* check if a new sequence has been initialized */
      if (mouse->state != old_state)
      {
         mouse->toon_state = mouse->sub_state;
         mouse->work_var = 0;
         mouse_reinit(mouse);
      }
   }
   
   /* reset the sub_state */
   mouse->sub_state = -1;

   /* process delay counter */
   if (mouse->work_var1&0xff00)
   {
      temp = mouse->work_var1 & 0x00ff;
      temp--;
      if (temp > 0)
      {
         mouse->work_var1 &= 0xff00;
         mouse->work_var1 += temp;
      }
      else
         mouse->work_var1 = 0;
   }

   /* process animation */
   if(mouse_tables[mouse->toon_state].mouse_func)
      mouse_tables[mouse->toon_state].mouse_func(mouse);
}


/* * * * *
*
*  void load_mouse_shapes(void);
*
* * * * */
void load_mouse_shapes(void)
{
}



/* * * * *
*
*  void free_mouse_shape(void);
*
*  This function will free the mouse character shapes.
*
* * * * */
void free_mouse_shapes(void)
{
}



/* * * * *
*
*  CHAR preempt_mouse(PART *mouse);
*
*  This function will return 0, if the mouse is currently in an animation
*  sequence that should not be interrupted. 1 otherwise.
*
* * * * */
CHAR preempt_mouse(PART *mouse)
{
   switch (mouse->toon_state)
   {
      case SID_GUM_INDEX:
         if (mouse->state == MOUSE_GUM_FLOAT_STATE)
            return(1);
         else
            return(0);
      case SID_CLIMB_INDEX:
      case SID_TUNNEL_INDEX:
      case SID_BOMB_INDEX:
      case SID_HDRYR_INDEX:
      case SID_DRAGON_INDEX:
      case SID_HAIR_INDEX:
      case SID_BANANA_INDEX:
      case SID_LUNCH_INDEX:
         return(0);
      default:
         return(1);
   }
}


/* * * * *
*
*  short mouse_observation(PART *mouse);
*
*  This function will set the mouse->sub_state variable of the specified part
*  to perform the observation seen. It will also reorient the mouse accordingly.
*  It returns the sub_state value assigned.
*
* * * * */
short mouse_observation(PART *mouse)
{
   #define SID_X_RANGE              CHARACTER_X_RANGE
   #define SID_Y_THRESHOLD          10

   PART *pptr;
   short return_val,flip;
   short x,y,w,h;
   short check_left,check_right;
   short mouse_mid_x;
   short pptr_mid_x;
   short being_chased;

   return_val = -1;
   being_chased = 0;

   /* check if the mouse is not vertically stable */
   if ((abs(mouse->speed.y >> SCALE_SHIFT) > 1) ||
      (mouse->scrn_loc.y != mouse->old_old_scrn_loc.y) ||
      (run_count < 2))
      return(return_val);

   /* check if the mouse still has a valid link */
   if (((pptr = mouse->toon_link) != 0) && !(pptr->flags2 & F2_INACTIVE) &&
      (pptr->type == PT_AL_CAT))
   {
      /* check if the cat is still chasing the mouse */
      switch (pptr->toon_state)
      {
         case CAT_WALK_INDEX:
         case CAT_SPIN_INDEX:
         case CAT_RUN_INDEX:
         case CAT_VAC2_INDEX:
         case CAT_POUNCE_INDEX:
            being_chased = 1;
            
            /* change the mouse sub_state to reflect the chasing cat */
            /* NOTE: a more interesting sub_state can replace this assignment */
            /* below */
            if (((mouse->work_var1 >> SID_SHIFT) != SID_TAKE_INDEX) &&
               (mouse->toon_state != SID_RUN_INDEX))
               mouse->sub_state = SID_TAKE_INDEX;
            else
            {
               /* This circumvents the below code. */
               if (mouse->toon_state != SID_RUN_INDEX)
                  sid_flip(mouse,F2_FLIP_H_DRAW);
   
               mouse->sub_state = SID_RUN_INDEX;
            }
            break;
         default:
         {
            mouse->toon_link = 0;
         
            /* set the sub state explicitly. This will be changed if a  */
            /* more interesting case is found below. */
            switch (mouse->toon_state)
            {
               case SID_RUN_INDEX:
                  mouse->sub_state = SID_STOP_INDEX;
                  break;
               default:
                  mouse->sub_state = SID_ROOT_INDEX;
            }
         }
      }
   }

   /* set up query rectangle */
   x = -SID_X_RANGE;
   y = 0;
   w = (SID_X_RANGE<<1) + mouse->base_size.x;
   h = mouse->base_size.y;
   flip = mouse->flags2 & F2_FLIP_H_DRAW;
   check_left = check_right = 1;
   mouse_mid_x = mouse->scrn_loc.x+mouse->offset.x+(mouse->base_size.x>>1);
   
   /* make the query list of visable objects */
   tn_query_dist(mouse,F1_STATIC_L|F1_MOVE_L,x,y,w,h);
   pptr = mouse->qptr;
   while (pptr)
   {
      /* check if the mouse is being chased by the cat */
      if (being_chased)
      {
         switch (pptr->type)
         {
            case PT_TUNNEL:
            case PT_LADDER:
            case PT_M_GLASS:
               break;
            default:
               goto SID_BEING_CHASED;
         }
      }

      /* calculate the midpoint of the observed part */
      pptr_mid_x = pptr->scrn_loc.x + pptr->offset.x + (pptr->size.x >> 1);

      /* check if the object can be seen from the right */
      if (check_right && (mouse_mid_x < pptr_mid_x))
      {
         return_val = mouse_query_switch(mouse, pptr);

         /* check if the object is opaque. If so then remember it. */
         if (is_opaque(mouse,pptr,SID_Y_THRESHOLD))
            check_right = 0;
      }

      /* check if the object can be seen from the left */
      if (check_left && (mouse_mid_x > pptr_mid_x))
      {
         return_val = mouse_query_switch(mouse, pptr);
         
         /* check if the object is opaque. If so then remember it. */
         if (is_opaque(mouse,pptr,SID_Y_THRESHOLD))
            check_left = 0;
      }

      if (return_val != -1)
      {
         /* set the toon link; */
         mouse->toon_link = pptr;
      
         /* adjust the orientation of the mouse */
         /* NOTE: flip is a variable which contains the original orientation */
         /* of the mouse */
         if (flip)
         {
            if (pptr->scrn_loc.x < mouse_mid_x)
               sid_flip(mouse, F2_FLIP_H_DRAW);
         }
         else
         {
            if (pptr->scrn_loc.x > mouse_mid_x)
               sid_flip(mouse, F2_FLIP_H_DRAW);
         }

         /* return the value of the index of the interaction closest to the mouse */
         return((mouse->sub_state = return_val));
      }
      else
SID_BEING_CHASED:
         pptr = pptr->qptr;
   }

   /* check if the mouse still has a valid link */
   if (!being_chased)
   {
      /* check if the mouse still has a valid link but can not decide what to  */
      /* do. */
      if (  (return_val == -1)
         && ((pptr = mouse->toon_link) != 0)
         && !(pptr->flags2 & F2_INACTIVE))
      {
         /* check if the link can still be seen. */
         /* NOTE: the full on check is not needed because the link was  */
         /* previously established. */
         if ((pptr->scrn_loc.y < mouse->scrn_loc.y + mouse->base_size.y) &&
            (pptr->scrn_loc.y + pptr->base_size.y > mouse->scrn_loc.y))
            return(return_val);
         else
         {
            mouse->toon_link = 0;
         
            /* set the sub state explicitly. This will be changed if a  */
            /* more interesting case is found below. */
            switch (mouse->toon_state)
            {
               case SID_RUN_INDEX:
                  return(mouse->sub_state = SID_STOP_INDEX);
               default:
                  return(mouse->sub_state = SID_ROOT_INDEX);
            }
         }
      }
      else
         mouse->toon_link = 0;
   }

   return(-1);
}


/* * * * *
*
*  short mouse_query_switch(PART *mouse, PART *pptr);
*
*  This function performs the generic switch on the pptr.
*
* * * * */
short mouse_query_switch(PART *mouse, PART *pptr)
{
   PART *cat;
   short x,y,w,h,mouse_x,mouse_y,mouse_w,mouse_h;

   switch (pptr->type)
   {
      case PT_AL_CAT:
         cat = pptr;
         switch (cat->toon_state)
         {
            /* if the cat is in a funny situation then the mouse will laugh */
            case CAT_CRACK_INDEX:
            case CAT_SHAKE_INDEX:
            case CAT_FLAIL_INDEX:
/*            case CAT_YARN_INDEX: */
/*            case CAT_SHOT_INDEX: */
            case CAT_ANGEL_INDEX:
            case CAT_SPINAW_INDEX:
            case CAT_RUNAW_INDEX:
               if ((mouse->work_var1 >> SID_SHIFT) != SID_GIGGLE_INDEX)
                  return(SID_GIGGLE_INDEX);
               break;

            /* if the cat is in the root position then the mouse will coax him */
            /* on */
            case CAT_ROOT_INDEX:
               if ((mouse->work_var1 >> SID_SHIFT) != SID_BRONX_INDEX)
                  return(SID_BRONX_INDEX);
               break;

            /* if the cat is moving toward the mouse then the mouse will be */
            /* frightened. */
            case CAT_WALK_INDEX:
            case CAT_RUN_INDEX:
            case CAT_SPIN_INDEX:
               /* check if the mouse is currently running away from the cat */
               if (mouse->toon_state == SID_RUN_INDEX)
                  break;

               /* check the orientation of the cat to the mouse. */
               /* Are they facing each other? */
               if (((cat->scrn_loc.x < mouse->scrn_loc.x) &&
                  !(cat->flags2 & F2_FLIP_H_DRAW)) ||
                  ((cat->scrn_loc.x > mouse->scrn_loc.x) &&
                  (cat->flags2 & F2_FLIP_H_DRAW)))
               {
                  if ((mouse->work_var1 >> SID_SHIFT) != SID_TAKE_INDEX)
                  {
                     return(SID_TAKE_INDEX);
                  }
                  else
                  {
                     sid_flip(mouse,F2_FLIP_H_DRAW);
                     return(SID_RUN_INDEX);
                  }
               }
               break;
         }
         /* mouse should go about his business */
         return(-1);
      case PT_LADDER:
         if (  ((mouse->work_var1 >> SID_SHIFT) == SID_CLIMB_INDEX)
            || (mouse->toon_state == SID_CLIMB_INDEX))
            return(-1);

         x = pptr->scrn_loc.x;
         y = pptr->scrn_loc.y;
         h = pptr->size.y;
         w = pptr->size.x;
         mouse_x = mouse->scrn_loc.x;
         mouse_y = mouse->scrn_loc.y;
         mouse_w = mouse->base_size.x;
         mouse_h = mouse->base_size.y;

         /* check if the mouse is out of range of the ladder */
         if (  (mouse_x + mouse_w < x)
            || (x + w < mouse_x)
            || (mouse_y + mouse_h < y)
            || (y + h < mouse_y))
            return(-1);
         else
            return(SID_CLIMB_INDEX);
      case PT_M_GLASS:
         return(magnify_check_mouse(pptr, mouse));
      case PT_GUM:
      case PT_CHEESE:
         return(SID_WALK_INDEX);
      case PT_BANANA:
         if (pptr->state != BANANA_PEEL)
            return(SID_WALK_INDEX);
         else
            return(-1);
      case PT_BOMB:
         if (pptr->state && (abs(pptr->qdist.x) < 60))
         {
            return(SID_TAKE_INDEX);
         }
         return(-1);
      case PT_DRAGON:
         /* This checks the orientation of the gun to the mouse. */
         if (pptr->state && (abs(pptr->qdist.x) < 60) &&
            (((pptr->scrn_loc.x < mouse->scrn_loc.x) &&
            (pptr->flags2 & F2_FLIP_H_DRAW)) ||
            ((pptr->scrn_loc.x > mouse->scrn_loc.x) &&
            !(pptr->flags2 & F2_FLIP_H_DRAW))))
         {
            return(SID_TAKE_INDEX);
         }
         return(-1);
      case PT_HANDGUN:
         /* This checks the orientation of the gun to the mouse. */
         if (pptr->state &&
            (((pptr->scrn_loc.x < mouse->scrn_loc.x) &&
            !(pptr->flags2 & F2_FLIP_H_DRAW)) ||
            ((pptr->scrn_loc.x > mouse->scrn_loc.x) &&
            (pptr->flags2 & F2_FLIP_H_DRAW))))
         {
            return(SID_TAKE_INDEX);
         }
         return(-1);
      case PT_SCISSORS:
         if (!pptr->state &&
            (((mouse->scrn_loc.x > pptr->scrn_loc.x) &&
            !(pptr->flags2 & F2_FLIP_H_DRAW)) ||
            ((mouse->scrn_loc.x<pptr->scrn_loc.x+pptr->size.x) &&
            (pptr->flags2 & F2_FLIP_H_DRAW))))
         {
            return(SID_WALK_INDEX);
         }
         return(-1);
      case PT_TUNNEL:
         if ((mouse->work_var1 >> SID_SHIFT) != SID_TUNNEL_INDEX)
         {
            /* check the placement of the mouse */
            if (  (mouse->scrn_loc.y > pptr->scrn_loc.y + 4)  
               && (mouse->scrn_loc.y < pptr->scrn_loc.y + 12)  
               && (mouse->scrn_loc.x > pptr->scrn_loc.x)  
               && (mouse->scrn_loc.x < pptr->scrn_loc.x + pptr->base_size.x))
            {
               /* NOTE: I am explicitly overwriting the toon_link and memory fields */
               /* of the mouse. It may have some wierd repercussions if the  */
               /* sub_state fails to change the toon_state */
               mouse->memory = mouse->toon_state;
               mouse->toon_link = pptr;
               return(SID_TUNNEL_INDEX);
            }
         }
      default:
         return(-1);
   }
}



/* * * * *
*
*  void mouse_root(PART *mouse);
*
* * * * */
void mouse_root(PART *mouse)
{
   #define SID_ROOT_TIME      90

   if (++mouse->work_var > SID_ROOT_TIME)
      mouse->sub_state = SID_WAIT1_INDEX;

   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;

   mouse_observation(mouse);
}



/* * * * *
*
*  void mouse_take(PART *mouse);
*
* * * * */
void mouse_take(PART *mouse)
{
   #define TAKE_RATE          10
   #define TAKE_REST          10

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_TAKE,1,0);

   if (++mouse->work_var > TAKE_RATE)
   {
      mouse->work_var1 = (SID_TAKE_INDEX << SID_SHIFT) | TAKE_REST;
      mouse->sub_state = SID_ROOT_INDEX;
   }
}

/* * * * *
*
*  void mouse_run(PART *mouse);
*
* * * * */
void mouse_run(PART *mouse)
{
   #define SID_RUN_TIME    24
   
   /* offset coordinates */
   const static char far sid_run_os[SID_RUN_NUM_STATES] =
   {
      -6,-5,-4
   };

   short sign;

   /* reset the speed */
   mouse->speed.x = 0;

   /* animate the mouse run */
   if (++mouse->state >= SID_RUN_SEQ + SID_RUN_NUM_STATES)
   {
      mouse->state = SID_RUN_SEQ;
      jtp_sx_play(SX_SID_RUN,0,0);
   }

   if (mouse->flags2 & F2_FLIP_H_DRAW)
      sign = -1;
   else
      sign = 1;

   mouse->speed.x=sign*short_to_pix(sid_run_os[mouse->state-SID_RUN_SEQ]<<1);
   mouse_reinit(mouse);

   /* check for falling */
   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;

   /* check surroundings */
   mouse->work_var++;
   if ((mouse_observation(mouse) == -1) &&
      (mouse->work_var > SID_RUN_TIME) &&
      !(mouse->toon_link))
   {
      mouse->sub_state = SID_STOP_INDEX;
      mouse->speed.x = 0;
   }
}


/* * * * *
*
*  void mouse_giggle(PART *mouse);
*
* * * * */
void mouse_giggle(PART *mouse)
{
   const static char far state_array[] =
   {
      0,1,0,2,0,1,0,1,0,2,0,1,
   };
   #define GIGGLE_NUM_STATES    (sizeof(state_array)/sizeof(char))
   #define GIGGLE_RATE          2

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_GIGGLE,2,0);

   if (++mouse->work_var < GIGGLE_NUM_STATES * GIGGLE_RATE)
   {
      if (!(mouse->work_var % GIGGLE_RATE))
      {
         mouse->state = state_array[mouse->work_var / GIGGLE_RATE] +
            SID_GIGGLE_SEQ;
         mouse_reinit(mouse);
      }
   }
   else
      mouse->sub_state = SID_ROOT_INDEX;
}


/* * * * *
*
*  void mouse_bronx(PART *mouse);
*
* * * * */
void mouse_bronx(PART *mouse)
{
   const static char far state_array[] =
   {
      0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1
   };
   #define BRONX_NUM_STATES    (sizeof(state_array)/sizeof(char))
   
   if (!mouse->work_var)
      jtp_sx_play(SX_SID_BRONX,0,0);

   if (++mouse->work_var < BRONX_NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] + SID_BRONX_SEQ;
      mouse_reinit(mouse);
   }
   else
      mouse->sub_state = SID_ROOT_INDEX;
}


/* * * * *
*
*  void mouse_fall(PART *mouse);
*
* * * * */
void mouse_fall(PART *mouse)
{
   /* check for sound effects */
   if (!mouse->work_var)
      jtp_sx_play(SX_SID_FALL,1,0);

   /* this is only done for consistency */
   mouse->work_var++;

   if (mouse->state < SID_FALL_SEQ + SID_FALL_NUM_STATES - 1)
      mouse->state++;
   else
      mouse->state = SID_FALL_SEQ;

   mouse_reinit(mouse);
}


/* * * * *
*
*  void mouse_splat(PART *mouse);
*
* * * * */
#pragma argsused
void mouse_splat(PART *mouse)
{
#if 0
   short index,sign;

   /* offset coordinates */
   const static signed char far sid_splat_os[][3] =
   {
      {-6,29,1},{-6,29,1},{11,-6,2},{19,-31,3},{-8,7,4},{10,22,5},{-1,4,6},
      {0,-6,7},{-12,-6,8},{-11,7,9},{-2,4,2},{6,-4,10},{9,-6,4},{10,7,7}
   };
   #define SPLAT_NUM_OFFSETS    (sizeof(sid_splat_os)/(sizeof(char)*3))
   #define SPLAT_RATE           2


   mouse->speed.x = mouse->speed.y = 0;
   
   if (++mouse->work_var < SPLAT_NUM_OFFSETS * SPLAT_RATE)
   {
      if (!(mouse->work_var % SPLAT_RATE))
      {
         index = mouse->work_var / SPLAT_RATE;

         if (mouse->flags2 & F2_FLIP_H_DRAW)
            sign = 1;
         else
            sign = -1;

         mouse->state = sid_splat_os[index][2] + SID_SPLAT_SEQ - 1;
         mouse->speed.x = sign * short_to_pix(sid_splat_os[index][0]);
         mouse->speed.y = short_to_pix(sid_splat_os[index][1]);
         mouse_reinit(mouse);
      }
   }
   else
      mouse->sub_state = SID_ROOT_INDEX;
#endif
}

/* * * * *
*
*   mouse_wait(PART *mouse);
*
* * * * */
#pragma argsused
void mouse_wait(PART *mouse)
{
}


/* * * * *
*
*  void mouse_hair(PART *mouse);
*
* * * * */
void mouse_hair(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,1,1,1,1,1,1,1,2,2,2,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,
      5,5,6,7,8,7,9,7,8,7,9,7,7,7,7,7,7,7,7,10,10,10,11,11,12,12,13,13,
      13,13,13,14,15,16,17
   };

   #define HAIR_NUM_STATES  (sizeof(state_array)/sizeof(char))
   #define HAIR_RATE   2

   if (!(++mouse->work_var % HAIR_RATE))
   {
      if (mouse->work_var < HAIR_NUM_STATES * HAIR_RATE)
      {
         mouse->state = state_array[mouse->work_var/HAIR_RATE]-1+SID_HAIR_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 1 + SID_HAIR_SEQ)
            jtp_sx_play(SX_SID_HAIR_HIT,3,0);
         if (  (mouse->state == 6 + SID_HAIR_SEQ)
            && (mouse->old_state == 5 + SID_HAIR_SEQ))
            jtp_sx_play(SX_SID_HAIR_STATUE,1,0);
         if (mouse->state == 10 + SID_HAIR_SEQ)
            jtp_sx_play(SX_SID_HAIR_FALL,1,0);
      }
      else
         kill_character(mouse);
   }
}


/* * * * *
*
*  void mouse_cut(PART *mouse);
*
*  This function assume that the specified mouse is in the correct position.
*
* * * * */
void mouse_cut(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,2,2,2,2,3,3,3,3,4,4,4
   };
   #define CUT_NUM_STATES     (sizeof(state_array)/sizeof(char))

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      mouse->speed.x = mouse->speed.y = 0;
      character_from_move_to_static(mouse);
   }

   if (++mouse->work_var < CUT_NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] - 1 + SID_CUT_SEQ;
      mouse_reinit(mouse);
      
      /* check if the scissors should be cut */
      if (  (mouse->state == 3 + SID_CUT_SEQ)
         && (mouse->old_state == 2 + SID_CUT_SEQ)
         && (mouse->toon_link)
         && (mouse->toon_link->type == PT_SCISSORS))
         mouse->toon_link->sub_state = 1;
   }
   else
   {
      character_from_static_to_move(mouse);
      mouse->sub_state = SID_ROOT_INDEX;
   }
}


/* * * * *
*
*  void mouse_whop(PART *mouse);
*
*  This function assume that the specified mouse is in the correct position.
*
* * * * */
#pragma argsused
void mouse_whop(PART *mouse)
{
}

/* * * * *
*
*  void mouse_climb(PART *mouse);
*
*  This function assume that the specified mouse is in the correct position.
*
* * * * */
void mouse_climb(PART *mouse)
{
   #define CLIMB_RATE            2
   #define CLIMB_REST1           10
   #define CLIMB_NUM_OFFSETS     4

   short index, exit_y, mouse_y;
   PART *ladder;

   /* offset coordinates */
   const static signed char far sid_climb_os[CLIMB_NUM_OFFSETS][3] =
   {
      {-1,-5,1-1},{1,-6,2-1},{-1,-7,3-1},{1,-6,2-1}
   };
   const static signed char far sid_fclimb_os[CLIMB_NUM_OFFSETS][3] =
   {
      {-1,6,0},{1,7,1},{-1,6,2},{1,5,1}
   };

   if (!(++mouse->work_var % CLIMB_RATE))
   {
      if (mouse->work_var == CLIMB_NUM_OFFSETS * CLIMB_RATE)
         mouse->work_var = 0;

      /* animate the climbing of the ladder */
      index = mouse->work_var / CLIMB_RATE;
      if (mouse->memory & MEMORY_DOWN_BIT)
      {
         mouse->state = sid_fclimb_os[index][2] + SID_CLIMB_SEQ;
         mouse->scrn_loc.y += sid_fclimb_os[index][1];
      }
      else
      {
         mouse->state = sid_climb_os[index][2] + SID_CLIMB_SEQ;
         mouse->scrn_loc.y += sid_climb_os[index][1];
      }

      mouse_y = mouse->scrn_loc.y + (mouse->size.y >> 1);
      ladder = mouse->toon_link;

      /* check for the end of the ladder */
      if (  (mouse_y > ladder->scrn_loc.y + ladder->size.y)
         || (mouse_y < ladder->scrn_loc.y))
      {
         /* reverse the direction of sid and recalculate the exit location */
         mouse->scrn_loc.y = mouse->old_scrn_loc.y;
         mouse->memory ^= MEMORY_DOWN_BIT;
         mouse->memory &= MEMORY_EXIT_BLOCK ^ 0xffff;
         mouse->memory |= ladder_exit(mouse,ladder,
            mouse->memory&MEMORY_DOWN_BIT,1) << EXIT_SCALE;

         /* verify that the mouse has an exit block */
         if (!(mouse->memory & MEMORY_DOWN_BIT) &&
            ((mouse->memory&MEMORY_EXIT_BLOCK)>>EXIT_SCALE)==MEMORY_NO_EXIT)
            mouse->memory &= 0xffff ^ MEMORY_EXIT_BLOCK; 
      }

      mouse->loc.y = (long)mouse->scrn_loc.y << SCALE_SHIFT;
      mouse_reinit(mouse);

      if (  (mouse->state == SID_CLIMB_SEQ)
         || (mouse->state == 2 + SID_CLIMB_SEQ))
         jtp_sx_play(SX_SID_CLIMB,0,0);

      mouse_y = (mouse->scrn_loc.y >> BLOCK_SCALE);
      exit_y = ((mouse->memory & MEMORY_EXIT_BLOCK) >> EXIT_SCALE) -
         (mouse->size.y >> BLOCK_SCALE);

      /* check current location compared to the exit location. */
      if (  (mouse_y == exit_y)
         || (mouse_y == exit_y + 1))
      {
         /* exit climb sequence. */
         mouse->toon_link = 0;

         /* orient the mouse  */
         if (  ((mouse->memory & MEMORY_ORIENT_LEFT_BIT)
            && (mouse->flags2 & F2_FLIP_H_DRAW))
            || (!(mouse->memory & MEMORY_ORIENT_LEFT_BIT)
            && (!(mouse->flags2 & F2_FLIP_H_DRAW))))
            sid_flip(mouse, F2_FLIP_H_DRAW);

         /* reposition mouse on the new floor. */
         mouse->loc.y =
            mouse->old_old_scrn_loc.y =
            mouse->old_scrn_loc.y =
            mouse->scrn_loc.y = 
               (((mouse->memory & MEMORY_EXIT_BLOCK) >> EXIT_SCALE)
               <<BLOCK_SCALE) - mouse->base_size.y + 2;

         mouse->loc.x = mouse->old_scrn_loc.x = mouse->scrn_loc.x;
         mouse->loc.y <<= SCALE_SHIFT;
         mouse->loc.x <<= SCALE_SHIFT;
         mouse->work_var1 = (SID_CLIMB_INDEX << SID_SHIFT) | CLIMB_REST1;
         mouse->work_var = mouse->speed.y = 0;
         character_from_static_to_move(mouse);

         /* check if nothing interesting was seen */
         if (mouse_observation(mouse) == -1)
         {
            /* default to the previous state */
            if (mouse->memory & MEMORY_RUN_BIT)
            {
               mouse->toon_state = mouse->sub_state = SID_RUN_INDEX;
               mouse->state = SID_RUN_SEQ;
            }
            else
            {
               mouse->toon_state = mouse->sub_state = SID_WALK_INDEX;
               mouse->state = SID_WALK_SEQ;
            }
         }
         else
         {
            mouse->toon_state = mouse->sub_state;
            mouse->state = abs(mouse_tables[mouse->sub_state].index2seq);
         }
      }
      else
      {
         /* check if the mouse has past the intended exit */
         if (  ((mouse->memory & MEMORY_DOWN_BIT)
            && (mouse_y > exit_y))
            || (!(mouse->memory & MEMORY_DOWN_BIT)
            && (mouse_y < exit_y))) 
         {
            mouse->memory ^= MEMORY_DOWN_BIT;
            mouse->memory &= MEMORY_EXIT_BLOCK ^ 0xffff;
            mouse->memory |= ladder_exit(mouse,ladder,
               mouse->memory&MEMORY_DOWN_BIT,1) << EXIT_SCALE;

            /* verify that the mouse has an exit block */
            if (!(mouse->memory & MEMORY_DOWN_BIT) &&
               (((mouse->memory&MEMORY_EXIT_BLOCK)>>EXIT_SCALE)
               ==MEMORY_NO_EXIT))
               mouse->memory &= 0xffff ^ MEMORY_EXIT_BLOCK; 
         }
      }
   }
}


/* * * * *
*
*  void mouse_walk(PART *mouse);
*
* * * * */
void mouse_walk(PART *mouse)
{
   short sign;

   /* offset coordinates */
   const static signed char far sid_walk_os[] =
   {
      -5,-8,-5,-4,-5,-5,-5,-4,-5
   };
   #define SID_WALK_NUM_OFFSETS  (sizeof(sid_walk_os)/sizeof(char))
   #define SID_WALK_TIME         24

   /* reset the mouse speed */
   mouse->speed.x = 0;

   /* animate the mouse walk */
   if (++mouse->state >= SID_WALK_SEQ + SID_WALK_NUM_STATES)
      mouse->state = SID_WALK_SEQ;

   if (mouse->state == 2 + SID_WALK_SEQ)
      jtp_sx_play(SX_SID_WALK,0,0);
   if (mouse->state == 6 + SID_WALK_SEQ)
      jtp_sx_play(SX_SID_WALK,0,0);

   if (mouse->flags2 & F2_FLIP_H_DRAW)
      sign = -1;
   else
      sign = 1;

   mouse->speed.x = sign*short_to_pix(sid_walk_os[mouse->state-SID_WALK_SEQ]);
   mouse_reinit(mouse);

   /* check for falling */
   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;
   
   /* check environments */
   if ((mouse_observation(mouse) == -1) &&
      (mouse->work_var++ > SID_WALK_TIME) &&
      !(mouse->toon_link))
   {
      mouse->sub_state = SID_ROOT_INDEX;
      mouse->speed.x = 0;
   }
}

/* * * * *
*
*  void mouse_gun(PART *mouse);
*
* * * * */
void mouse_gun(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,
      5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,5,5,6,6,7,
      7,8,8,9,9,10,10,11,11,12,12,5,5,6,6,7,7,8,8,9,9,
      10,10,11,11,12,12,5,5,6,6,7,7,8,8,9,9,10,10,11,11,
      12,12,5,1
   };
   #define MOUSE_GUN_NUM_STATES    (sizeof(state_array)/sizeof(char))

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_GUN_ROUND,1,0);

   mouse->speed.x = 0;
   if (++mouse->work_var < MOUSE_GUN_NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] -1 + SID_GUN_SEQ;
      mouse_reinit(mouse);

      if (  (mouse->state == 4 + SID_GUN_SEQ)
         && (mouse->old_state == 3 + SID_GUN_SEQ))
         jtp_sx_play(SX_SID_GUN_DIZZY,2,0);
   }
   else
      mouse->sub_state = SID_SHAKE_INDEX;
}

/* * * * *
*
*  void mouse_dustb(PART *mouse);
*
* * * * */
void mouse_dustb(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,2,1,1,1,1,1,2,2,3,3,2,2,1,1,1,1,1,1,
      2,2,3,4,3,4,3,4,3,4,3,4,3,4,5,6,7,5,6,7,5,
      6,7
   };
   #define DUSTB_NUM_STATES   (sizeof(state_array)/sizeof(char))
   #define DUSTB_RATE         2

   PART *pptr;
   short speed;

   mouse->speed.x = 0;

   if (!(++mouse->work_var % DUSTB_RATE))
   {
      if (mouse->work_var < DUSTB_NUM_STATES * DUSTB_RATE)
      {
         mouse->state = state_array[mouse->work_var / DUSTB_RATE] - 1 +
            SID_DUSTB_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == SID_DUSTB_SEQ)
            jtp_sx_play(SX_SID_DUSTBUNNY_GASP,1,1);
         if (  (mouse->state == 4 + SID_DUSTB_SEQ)
            && (mouse->old_state == 3 + SID_DUSTB_SEQ))
            jtp_sx_play(SX_SID_DUSTBUNNY_SNEEZE,3,1);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }

   /* check if the mouse should make the sneeze */
   if (mouse->state > 4 + SID_DUSTB_SEQ)
   {
      if (!(mouse->flags2 & F2_FLIP_H_DRAW))
      {
         tn_query_dist(mouse,F1_MOVE_L,-93,15,68,32);
         speed = -TWO_PIX;
      }
      else
      {
         tn_query_dist(mouse,F1_MOVE_L,mouse->base_size.x+93-68,15,68,32);
         speed = TWO_PIX;
      }

      pptr = mouse->qptr;
      while (pptr)
      {
         pptr->speed.x += speed;
         check_term_velocity(pptr);
         pptr = pptr->qptr;
      }
   }
}

/* * * * *
*
*  void mouse_butt(PART *mouse);
*
* * * * */
void mouse_butt(PART *mouse)
{
   short sign;

   /* offset coordinates */
   const static char far state_array[] =
   {
      1,2,3,4,5,6
   };
   #define SID_BUTT_NUM_OFFSETS  (sizeof(state_array)/sizeof(char))
   #define BUTT_RATE             2

   if (!(++mouse->work_var % BUTT_RATE))
   {
      if (mouse->work_var < SID_BUTT_NUM_OFFSETS * BUTT_RATE)
      {
         mouse->state = state_array[mouse->work_var / BUTT_RATE] - 1 +
            SID_BUTT_SEQ;
         mouse_reinit(mouse);

         /* check if the mouse should jump */
         if (mouse->state == SID_BUTT_SEQ + 1)
         {
            if (mouse->flags2 & F2_FLIP_H_DRAW)
               sign = 1;
            else
               sign = -1;

            mouse->speed.x = sign * THREE_PIX;
            mouse->speed.y = -NINE_PIX;
         }

         if (mouse->state == 1 + SID_BUTT_SEQ)
            jtp_sx_play(SX_SID_BUTT_YELL,3,0);
      }
   }
}

/* * * * *
*
*  void mouse_bonk(PART *mouse);
*
* * * * */
void mouse_bonk(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,1,2,2,2,2,2,3,4,5,6,7,7,8,8,7,7,8,8,7,7,8,
      8,7,7,8,8,7,7,8,8,7,7,8,8,7,7,8,8
   };
   #define BONK_NUM_STATES  (sizeof(state_array)/sizeof(char))
   #define BONK_RATE   2

   if (!(++mouse->work_var % BONK_RATE))
   {
      if (mouse->work_var < BONK_NUM_STATES * BONK_RATE)
      {
         mouse->state = state_array[mouse->work_var/BONK_RATE]-1+SID_BONK_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == SID_BONK_SEQ)
            jtp_sx_play(SX_SID_BONK_SQUEEK,1,0);
         if (mouse->state == 7 + SID_BONK_SEQ)
            jtp_sx_play(SX_SID_BONK_HEAD,1,0);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }
}

/* * * * *
*
*  void mouse_anvil(PART *mouse);
*
* * * * */
void mouse_anvil(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,2,3,4,5,6,7,8,2,3,9,4,6,7,8,3,9,4,7,8,3,9,4,7,8
   };
   #define ANVIL_NUM_STATES   (sizeof(state_array)/sizeof(char))
   #define ANVIL_RATE         2

   if (!(++mouse->work_var % ANVIL_RATE))
   {
      if (mouse->work_var < ANVIL_NUM_STATES * ANVIL_RATE)
      {
         mouse->state=state_array[mouse->work_var/ANVIL_RATE]-1+SID_ANVIL_SEQ;
         mouse_reinit(mouse);

         if (  (mouse->state == 1 + SID_ANVIL_SEQ)
            || (mouse->state == 8 + SID_ANVIL_SEQ))
            jtp_sx_play(SX_SID_ANVIL,1,0);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }
}

/* * * * *
*
*  void mouse_cheese(PART *mouse);
*
* * * * */
void mouse_cheese(PART *mouse)
{
   PART *link;

   const static char far state_array[] =
   {
      1,1,1,2,3,3,3,3,3,3,3,3,3,4,4,4,5,6,6,6,6,7,8,8,8,9
   };
   #define CHEESE_NUM_STATES  (sizeof(state_array)/sizeof(char))
   #define CHEESE_RATE        2

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
       jtp_sx_play(SX_SID_CHEESE_LIFT,2,0);

      /* kill the cheese part */
      if (((link = mouse->toon_link) != 0) && (link->type == PT_CHEESE))
      {
         kill_character(link);
         mouse->toon_link = 0;
      }
   }

   if (!(++mouse->work_var % CHEESE_RATE))
   {
      if (mouse->work_var < CHEESE_NUM_STATES * CHEESE_RATE)
      {
         mouse->state = state_array[mouse->work_var / CHEESE_RATE] -1 + 
            SID_CHEESE_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 5 + SID_CHEESE_SEQ)
            jtp_sx_play(SX_SID_CHEESE_CRASH,3,0);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }
}

/* * * * *
*
*  void mouse_lunch(PART *mouse);
*
* * * * */
void mouse_lunch(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,2,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,6,7,
      6,7,6,7,6,7,6,7,6,7,6,8,8,8,8,8,8,8,8,8,9,10,9,10,9,10,
      9,10,9,10,9,10,9,10,9,10,9,10,9,10,11,11,11,11,11,11,11,
      11,11,11,11,3,3,3,3,3,2,2,2,2,2,1,1
   };
   #define LUNCH_NUM_STATES  (sizeof(state_array)/sizeof(char))
   #define LUNCH_RATE   2

   if (!(++mouse->work_var % LUNCH_RATE))
   {
      if (mouse->work_var < LUNCH_NUM_STATES * LUNCH_RATE)
      {
         mouse->state = state_array[mouse->work_var / LUNCH_RATE] -1 + 
            SID_LUNCH_SEQ;
         mouse_reinit(mouse);

         if (  (mouse->state == 2 + SID_LUNCH_SEQ)
            && (mouse->old_state == 1 + SID_LUNCH_SEQ))
            jtp_sx_play(SX_SID_LUNCH_PAIL,3,0);
         if (  (mouse->state == 5 + SID_LUNCH_SEQ)
            && (mouse->old_state == 4 + SID_LUNCH_SEQ))
            jtp_sx_play(SX_SID_LUNCH_GASP,3,0);
         if (  (mouse->state == 7 + SID_LUNCH_SEQ)
            && (mouse->old_state == 5 + SID_LUNCH_SEQ))
            jtp_sx_play(SX_SID_LUNCH_CHOMP,3,0);
         if (mouse->state == 8 + SID_LUNCH_SEQ)
            jtp_sx_play(SX_SID_LUNCH_CHEW,3,0);
         if (  (mouse->state == 2 + SID_LUNCH_SEQ)
            && (mouse->old_state == 10 + SID_LUNCH_SEQ))
            jtp_sx_play(SX_SID_LUNCH_DONE,3,0);
      }
      else
      {
         /* force the preempt of the sequence */
         mouse->toon_state = mouse->sub_state = SID_ROOT_INDEX;
         mouse->state = SID_ROOT_SEQ;
         mouse->work_var = 0;
      }
   }
}

/* * * * *
*
*  void mouse_piano(PART *mouse);
*
*  This function assume that the specified mouse is in the correct position.
*
* * * * */
void mouse_piano(PART *mouse)
{
   PART *piano;
   short index;

   /* offset coordinates */
   const static signed char far sid_piano_os[][3] =
   {
      {32,6,1},{32,6,1},{49,3,2},{49,3,2},{49,3,2},{49,3,2},{49,3,2},
      {49,3,2},{49,3,2},{49,3,2},{49,3,2},{49,3,2},{49,0,2},{49,-3,2},
      {49,-6,2},{49,-10,2},{49,-13,2},{49,-16,2},{49,-20,2},{49,-20,2},
      {49,-20,2},{49,-20,2},{49,-20,2},{49,-20,2},{49,-20,2},{49,-20,2},
      {49,-20,2},{49,-20,2},{47,-16,2},{47,-15,3},{47,-10,3},{47,-2,3},
      {43,-4,4},{46,-6,5},{46,-9,5},{46,-8,5},{41,-6,6},{43,-4,4},{45,0,7}
   };
   #define SID_PIANO_NUM_OFFSETS    (sizeof(sid_piano_os)/(sizeof(char)*3))
   #define PIANO_REST           7

   /* check if the link is ok. */
   if (((piano = mouse->toon_link) == 0) || (piano->type != PT_PIANO))
   {
      mouse->sub_state = SID_ROOT_INDEX;
      character_from_static_to_move(mouse);
      return;
   }

   /* check if the piano is ready for the sid piano animation */
   if (piano->state == PIANO_REST)
   {
      index = ++mouse->work_var;

      /* check if the mouse should animate */
      if (index < SID_PIANO_NUM_OFFSETS)
         mouse->state = sid_piano_os[index][2] + SID_PIANO_SEQ - 1;
      else
      {
         kill_character(mouse);
         return;
      }

      /* reposition the mouse to align with the piano */
      mouse->loc.x = mouse->scrn_loc.x =
         piano->scrn_loc.x + sid_piano_os[index][0] - 18;
      mouse->loc.y = mouse->scrn_loc.y =
         piano->scrn_loc.y + sid_piano_os[index][1] + 20;
      mouse->loc.x <<= SCALE_SHIFT;
      mouse->loc.y <<= SCALE_SHIFT;
      mouse_reinit(mouse);

      /* force the redraw of the piano  */
      /* NOTE: This may not be very efficient--ask RICHR */
      part_to_er(piano,1|2);
   }
   else
   {
      if (!mouse->work_var)
      {
         /* reposition the mouse to align with the piano */
         mouse->loc.y = mouse->old_scrn_loc.y = mouse->scrn_loc.y += 7; 
         mouse->loc.y <<= SCALE_SHIFT;
         mouse_reinit(mouse);
         mouse->work_var = 1;
      }
   }

   /* make the border zero through out the sequence */
   mouse->border = 0;
}

/* * * * *
*
*  void mouse_hit_floor(PART *mouse);
*
* * * * */
void mouse_hit_floor(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define FLOOR_RATE            2

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_HIT_FLOOR,0,0);

   if (!(++mouse->work_var % FLOOR_RATE))
   {
      if (mouse->work_var < NUM_STATES * FLOOR_RATE)
      {
         mouse->state = state_array[mouse->work_var / FLOOR_RATE] - 1 +
            SID_HIT_FLOOR_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->sub_state = SID_SHAKE_INDEX;
   }
}


/* * * * *
*
*  void mouse_hit_ceiling(PART *mouse);
*
* * * * */
void mouse_hit_ceiling(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define CEILING_RATE            2

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_HIT_CEILING,0,0);

   if (!(++mouse->work_var % CEILING_RATE))
   {
      if (mouse->work_var < NUM_STATES * CEILING_RATE)
      {
         mouse->state = state_array[mouse->work_var / CEILING_RATE] - 1 +
            SID_HIT_CEILING_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->sub_state = SID_SHAKE_INDEX;
   }
}


/* * * * *
*
*  void mouse_hit_left_wall(PART *mouse);
*
* * * * */
void mouse_hit_left_wall(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define LEFT_WALL_RATE            2

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_HIT_WALL,0,0);

   if (!(++mouse->work_var % LEFT_WALL_RATE))
   {
      if (mouse->work_var < NUM_STATES * LEFT_WALL_RATE)
      {
         mouse->state = state_array[mouse->work_var / LEFT_WALL_RATE] - 1 +
            SID_HIT_LEFT_WALL_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }
}


/* * * * *
*
*  void mouse_hit_right_wall(PART *mouse);
*
* * * * */
void mouse_hit_right_wall(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define RIGHT_WALL_RATE            2

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_HIT_WALL,0,0);

   if (!(++mouse->work_var % RIGHT_WALL_RATE))
   {
      if (mouse->work_var < NUM_STATES * RIGHT_WALL_RATE)
      {
         mouse->state = state_array[mouse->work_var / RIGHT_WALL_RATE] - 1 +
            SID_HIT_RIGHT_WALL_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }
}


/* * * * *
*
*  void mouse_fly_up(PART *mouse);
*
* * * * */
void mouse_fly_up(PART *mouse)
{
   #define SID_FLY_UP_TIME      5

   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;

   if (++mouse->work_var > SID_FLY_UP_TIME)
      mouse->sub_state = SID_WAIT1_INDEX;
}

/* * * * *
*
*  void mouse_bomb(PART *mouse);
*
* * * * */
void mouse_bomb(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,5,5,5,5,5,6,6,6,6,6,5,5,5,5,5,
      7,7,7,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,
      16,17,17,18,18,19,19,20,20,21,21,21,22,22,22,23,23,23,7,7,7,24,
      24,24,24,24,24,24,24,24,24,24,25,25,25,26,26,26,27,27,27,28,28,
      28,29,29,29,30,30,30,25,25,25,26,26,26,27,27,27,28,28,28,29,29,29,
      30,30,30,25,25,25,25,24,24,24,24,24,24,31,31,31,31,31,31,31,32,32,
      32,33,33,33,34,34,34,35,35,35
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      /* kill the original velocity */
      mouse->speed.x = mouse->speed.y = 0;
      character_from_move_to_static(mouse);
   }

   if (++mouse->work_var < NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] - 1 + SID_BOMB_SEQ;
      mouse_reinit(mouse);

      if (  (mouse->state == 4 + SID_BOMB_SEQ)
         && (mouse->old_state == 3 + SID_BOMB_SEQ))
         jtp_sx_play(SX_SID_BOMB_GASP,3,0);
      if (mouse->state == 7 + SID_BOMB_SEQ)
         jtp_sx_play(SX_SID_BOMB_YELL,3,0);
      if (  (mouse->state == 24 + SID_BOMB_SEQ)
         && (mouse->old_state == 23 + SID_BOMB_SEQ))
         jtp_sx_play(SX_SID_BOMB_GIGGLE,3,0);
      if (mouse->state == 34 + SID_BOMB_SEQ)
         jtp_sx_play(SX_SID_BOMB_FALL,3,0);
   }
   else
      /* remove sid from the static list */
      if (mouse->work_var == NUM_STATES)
      {
         character_from_static_to_move(mouse);
         mouse->border = 0;
      }
}

/* * * * *
*
*  void mouse_shake(PART *mouse);
*
* * * * */
void mouse_shake(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,3,4,5,6,7,1,2,3,4,5,6,7,
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_SHAKE,1,0);

   if (++mouse->work_var < NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] - 1 + SID_SHAKE_SEQ;
      mouse_reinit(mouse);
   }
   else
      mouse->sub_state = SID_ROOT_INDEX;
}

/* * * * *
*
*  void mouse_dragon(PART *mouse);
*
* * * * */
void mouse_dragon(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,3,1,2,3,1,2,3,4,5,6,7,8,6,7,8,6,7,8,9,9,9,9,9,9,9,9,9,9,10,11
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define DRAGON_RATE            2

   if (!(++mouse->work_var % DRAGON_RATE))
   {
      if (mouse->work_var < NUM_STATES * DRAGON_RATE)
      {
         mouse->state = state_array[mouse->work_var / DRAGON_RATE] - 1 +
            SID_DRAGON_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 9 + SID_DRAGON_SEQ)
            jtp_sx_play(SX_SID_DRAGON_CRUMPLE,3,0);
      }
      else
         kill_character(mouse);
   }
}

/* * * * *
*
*  void mouse_hdryr(PART *mouse);
*
* * * * */
void mouse_hdryr(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,
      1,2,1,2,1,2,1,2,1,2,1,2,3,3,3,3,3,3,4,4,4,4,4,4,5,5,5,5,5,5
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define HDRYR_RATE            1
   PART *link;

   /* Handle special case when hair dryer stops */
   if (  ((link = mouse->toon_link) != 0)
      && (link->type == PT_HAIRDRYER)
      && (!link->sub_state))
   {
      mouse->toon_state = mouse->sub_state = SID_ROOT_INDEX;
      mouse->state = SID_ROOT_SEQ;
      mouse->work_var = 0;
      return;
   }

   mouse->speed.x = mouse->speed.y = 0;
   if (++mouse->work_var < NUM_STATES * HDRYR_RATE)
   {
      mouse->state = state_array[mouse->work_var / HDRYR_RATE] - 1 +
         SID_HDRYR_SEQ;
      mouse_reinit(mouse);
   }
   else
      kill_character(mouse);
}

/* * * * *
*
*  void mouse_gum(PART *mouse);
*
* * * * */
void mouse_gum(PART *mouse)
{
   PART *link;
   P_PART_ELEMENTS elements;
   short new_acel;

   const static char far state_array[] =
   {
      1,1,1,1,1,1,1,1,1,1,2,2,2,3,3,3,4,4,4,4,5,5,6,6,6,7,7,8,8,9,9,9,9,9,
      10,10,11,11,12,12,12,12,12,12,13,13,12,12,13,13,12,12,13,13,13,12,12,13,
      13,12,12,13,13,12,12,13,13,12,12,13,13,14,14,14,14,15,15,15,15,16,16,
      16,16,17,17,17,17,17,17,17,18
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define FLOAT_ACEL      -TWO_PIX

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      mouse->speed.x = mouse->speed.y = 0;

      /* cut the link and turn off the speed of the gum */
      if (((link = mouse->toon_link) != 0) && (link->type == PT_GUM))
      {
         link->speed.x = link->speed.y = 0;
         mouse->toon_link = 0;
      }
   }

   if (++mouse->work_var < NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] - 1 + SID_GUM_SEQ;
      mouse_reinit(mouse);

      if (mouse->state == 12 + SID_GUM_SEQ)
         jtp_sx_play(SX_SID_GUM_CHEW,2,0);
      if (  (mouse->state == 13 + SID_GUM_SEQ)
         && (mouse->old_state == 12 + SID_GUM_SEQ))
         jtp_sx_play(SX_SID_GUM_BLOW,2,0);
   }
   else
   {
      /* overwrite the adjust_falling function called just prior to this  */
      /* internal */
      elements = &prop[mouse->type];
      new_acel = FLOAT_ACEL - elements->acel;
      mouse->speed.y += new_acel;
      check_term_velocity(mouse);
      mouse->force = smuls(abs(mouse->speed.x)+abs(mouse->speed.y),
         mouse->mass);
   }
}


/* * * * *
*
*  void mouse_wait1(PART *mouse);
*
* * * * */
void mouse_wait1(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define WAIT1_RATE      4

   if (!(++mouse->work_var % WAIT1_RATE))
   {
      if (mouse->work_var < NUM_STATES * WAIT1_RATE)
      {
         mouse->state = state_array[mouse->work_var / WAIT1_RATE] - 1 +
            SID_WAIT1_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == SID_WAIT1_SEQ)
            jtp_sx_play(SX_SID_WAIT1,0,0);
      }
      else
         mouse_random_wait(mouse);
   }

   /* check for falling mouse */
   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;
   else
      mouse_observation(mouse);
}

/* * * * *
*
*  void mouse_wait2(PART *mouse);
*
* * * * */
void mouse_wait2(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define WAIT2_RATE      2

   if (!(++mouse->work_var % WAIT2_RATE))
   {
      if (mouse->work_var < NUM_STATES * WAIT2_RATE)
      {
         mouse->state = state_array[mouse->work_var / WAIT2_RATE] - 1 +
            SID_WAIT2_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == SID_WAIT2_SEQ)
            jtp_sx_play(SX_SID_WAIT2,0,0);
      }
      else
         mouse_random_wait(mouse);
   }

   /* check for falling mouse */
   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;
   else
      mouse_observation(mouse);
}

/* * * * *
*
*  void mouse_wait3(PART *mouse);
*
* * * * */
void mouse_wait3(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,1,2,1,2,1,2,1,2,1,2,1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define WAIT3_RATE      2

   if (!(++mouse->work_var % WAIT3_RATE))
   {
      if (mouse->work_var < NUM_STATES * WAIT3_RATE)
      {
         mouse->state = state_array[mouse->work_var / WAIT3_RATE] - 1 +
            SID_WAIT3_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 1 + SID_WAIT3_SEQ)
            jtp_sx_play(SX_SID_WAIT3,0,0);
      }
      else
         mouse_random_wait(mouse);
   }

   /* check for falling mouse */
   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;
   else
      mouse_observation(mouse);
}

/* * * * *
*
*  void mouse_wait4(PART *mouse);
*
* * * * */
void mouse_wait4(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,2,1,1,2,2,3,3,4,4,3,3,
      4,4,3,3,4,4,3,3,4,4,3,3,4,4,5,1,5,1,5,1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define WAIT4_RATE      2

   if (!(++mouse->work_var % WAIT4_RATE))
   {
      if (mouse->work_var < NUM_STATES * WAIT4_RATE)
      {
         mouse->state = state_array[mouse->work_var / WAIT4_RATE] - 1 +
            SID_WAIT4_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 2 + SID_WAIT4_SEQ)
            jtp_sx_play(SX_SID_WAIT4_1,0,0);
         if (mouse->state == 4 + SID_WAIT4_SEQ)
            jtp_sx_play(SX_SID_WAIT4_2,0,0);
      }
      else
         mouse_random_wait(mouse);
   }

   /* check for falling mouse */
   if (mouse->speed.y > MOUSE_FALLING)
      mouse->sub_state = SID_FALL_INDEX;
   else
      mouse_observation(mouse);
}

/* * * * *
*
*  void mouse_random_wait(PART *mouse);
*
* * * * */
void mouse_random_wait(PART *mouse)
{
   short index;

   index = my_random() % 6;
   switch (index)
   {
      case 0:
      case 1:
      case 2:
         mouse->sub_state = SID_WAIT1_INDEX;
         break;
      case 3:
         mouse->sub_state = SID_WAIT2_INDEX;
         break;
      case 4:
         mouse->sub_state = SID_WAIT3_INDEX;
         break;
      default:
         mouse->sub_state = SID_WAIT4_INDEX;
   }
}

/* * * * *
*
*  void mouse_stop(PART *mouse);
*
* * * * */
void mouse_stop(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,2,2,2,4,3,4,5,6,5,4,3,4,5,6,5
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define STOP_RATE            2

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_STOP_1,2,0);

   if (!(++mouse->work_var % STOP_RATE))
   {
      if (mouse->work_var < NUM_STATES * STOP_RATE)
      {
         mouse->state = state_array[mouse->work_var / STOP_RATE] - 1 +
            SID_STOP_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 2 + SID_STOP_SEQ)
            jtp_sx_play(SX_SID_STOP_2,1,0);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }
}

/* * * * *
*
*  void mouse_pin1(PART *mouse);
*
* * * * */
void mouse_pin1(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,3,3,3,3,4,4,5,
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PIN1_RATE            2

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      jtp_sx_play(SX_SID_PIN1_HIT,0,0);
      character_from_move_to_static(mouse);
   }
   
   if (!(++mouse->work_var % PIN1_RATE))
   {
      if (mouse->work_var < NUM_STATES * PIN1_RATE)
      {
         mouse->state = state_array[mouse->work_var / PIN1_RATE] - 1 +
            SID_PIN1_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 4 + SID_PIN1_SEQ)
            jtp_sx_play(SX_SID_PIN1_YELL,1,0);
      }
      else
      {
         /* Give the mouse an initial negative vertical velocity */
         if (mouse->work_var == NUM_STATES * PIN1_RATE)
         {
            character_from_static_to_move(mouse);
            mouse->speed.y = -(SIXTEEN_PIX + EIGHT_PIX);
         }

         /* check if the mouse has begun to fall */
         if (mouse->speed.y > MOUSE_FALLING)
            mouse->sub_state = SID_FALL_INDEX;
      }
   }
}


/* * * * *
*
*  void mouse_pin2(PART *mouse);
*
* * * * */
void mouse_pin2(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,3,4,5,6,6,6,6,6,6,7,8,8,7,8,8,7,8,8,8,7,8,8,8,9
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PIN2_RATE            2

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      jtp_sx_play(SX_SID_PIN2_HIT,0,0);
      character_from_move_to_static(mouse);
   }
   
   if (!(++mouse->work_var % PIN2_RATE))
   {
      if (mouse->work_var < NUM_STATES * PIN2_RATE)
      {
         mouse->state = state_array[mouse->work_var / PIN2_RATE] - 1 +
            SID_PIN2_SEQ;
         mouse_reinit(mouse);

         if (mouse->state == 7 + SID_PIN2_SEQ)
            jtp_sx_play(SX_SID_PIN2_YELL,1,0);
      }
      else
      {
         /* remove mouse from static list */
         if (mouse->work_var == NUM_STATES * PIN1_RATE)
            character_from_static_to_move(mouse);

         /* check if the mouse has begun to fall */
         if (mouse->speed.y > SID_FALL_THRESHOLD2)
            mouse->sub_state = SID_FALL_INDEX;
      }
   }
}

/* * * * *
*
*  void mouse_slide1(PART *mouse);
*
* * * * */
void mouse_slide1(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE1_RATE            2

   if (!(++mouse->work_var % SLIDE1_RATE))
   {
      if (mouse->work_var < NUM_STATES * SLIDE1_RATE)
      {
         mouse->state = state_array[mouse->work_var / SLIDE1_RATE] - 1 +
            SID_SLIDE1_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->work_var = 0;
   }
}


/* * * * *
*
*  void mouse_slide2(PART *mouse);
*
* * * * */
void mouse_slide2(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,3,4,5,6,1,2,3,4,5,6,1,2,3,4,5,6
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE2_RATE            2

   if (!(++mouse->work_var % SLIDE2_RATE))
   {
      if (mouse->work_var < NUM_STATES * SLIDE2_RATE)
      {
         mouse->state = state_array[mouse->work_var / SLIDE2_RATE] - 1 +
            SID_SLIDE2_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->work_var = 0;
   }
}


/* * * * *
*
*  void mouse_slide3(PART *mouse);
*
* * * * */
void mouse_slide3(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,3,1,2,3,1,2,3,1,2,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE3_RATE            2

   if (!(++mouse->work_var % SLIDE3_RATE))
   {
      if (mouse->work_var < NUM_STATES * SLIDE3_RATE)
      {
         mouse->state = state_array[mouse->work_var / SLIDE3_RATE] - 1 +
            SID_SLIDE3_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->work_var = 0;
   }
}


/* * * * *
*
*  void mouse_slide4(PART *mouse);
*
* * * * */
void mouse_slide4(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,1,2,1,2,1,2,1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE4_RATE            2

   if (!(++mouse->work_var % SLIDE4_RATE))
   {
      if (mouse->work_var < NUM_STATES * SLIDE4_RATE)
      {
         mouse->state = state_array[mouse->work_var / SLIDE4_RATE] - 1 +
            SID_SLIDE4_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->work_var = 0;
   }
}

/* * * * *
*
*  void mouse_vac(PART *mouse);
*
* * * * */
void mouse_vac(PART *mouse)
{          
   const static char far state_array[] =
   {
      1,1,2,
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define VAC_RATE        2

   if (!(++mouse->work_var % VAC_RATE))
   {
      if (mouse->work_var < NUM_STATES * VAC_RATE)
      {
         mouse->state = state_array[mouse->work_var / VAC_RATE] - 1 +
            SID_VAC_SEQ;
         mouse_reinit(mouse);
      }
      else
         mouse->work_var = 0;
   }
   mouse->sub_state = SID_ROOT_INDEX;
}

/* * * * *
*
*  void mouse_vac2(PART *mouse);
*
* * * * */
void mouse_vac2(PART *mouse)
{          
   const static char far state_array[] =
   {
      1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
      25,26,27,28,29,30,31,32,33,34,35,36,      /*,37,38,39,40 */
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define VAC2_RATE        2

   
   mouse->speed.x = mouse->speed.y = 0;
   if (!(++mouse->work_var % VAC2_RATE))
   {
      if (mouse->work_var < NUM_STATES * VAC2_RATE)
      {
         mouse->state = state_array[mouse->work_var / VAC2_RATE] - 1 +
            SID_VAC2_SEQ;
         mouse_reinit(mouse);
      }
      else
         kill_character(mouse);
   }
   
   /* Go to shake sequence. Vacuum will change it if it is still running */
   mouse->sub_state = SID_SHAKE_INDEX;
}

/* * * * *
*
*  void mouse_vac3(PART *mouse);
*
* * * * */
#pragma argsused
void mouse_vac3(PART *mouse)
{          
   mouse->sub_state = SID_ROOT_INDEX;
}

/* * * * *
*
*  void mouse_tunnel(PART *mouse);
*
* * * * */
void mouse_tunnel(PART *mouse)
{
   /* offset coordinates */
   const static signed char far sid_tunnel_os[][3] =
   {
      {1,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
      {0,0,0},{0,0,0},{0,0,0},{-12,0,1},{0,0,1},{-5,-22,2},
      {1,0,3},{-1,0,2},{1,0,3},{-1,0,2},{1,0,3},{-1,0,2},
      {1,0,3},{6,27,4},{0,-1,4},{0,1,4},{0,1,4},{7,-9,5},
      {-2,-15,6},{0,-4,6},{0,3,6},{3,12,5},{0,4,5},{0,1,5},
      {0,0,5},{0,0,5},{0,0,5},{0,0,5},{0,0,5},{0,0,5},
      {0,0,5},{0,0,5},{2,-6,7},{4,0,7},{4,0,7},{0,0,7},
      {-1,0,7},{1,0,7},{-1,0,7},{1,0,7},{-1,0,7},{1,0,7},
      {-1,0,7},{1,0,7},{-18,-5,8},{0,0,8},{1,1,9},{0,0,9},
      {0,13,10},{1,-1,11},{-1,-1,10},{1,1,11},{-1,0,10},{1,1,11},
      {-1,-1,10},{0,0,10},{1,1,11},{-5,-8,12},{-1,-4,13},{0,0,13},
      {0,0,13},{0,0,13},{0,0,13},{0,0,13},{0,0,13},{0,0,13},
      {0,0,14},{0,0,15},{0,0,16},{0,0,16},{0,0,16},{0,0,16},
      {0,0,17},{0,0,17},{0,0,17},{0,-1,18},{0,6,19},{0,0,20},
      {0,0,20},{0,0,20},{0,0,20},{0,0,20},{-1,3,21},{0,0,22},
      {0,5,23},{0,0,23},{15,4,24},{5,-6,0}
   };
   #define SID_TUNNEL_NUM_OFFSETS   (sizeof(sid_tunnel_os)/(sizeof(char)*3))
   #define COMING_OUT_STATE         54
   #define TUNNEL_RATE              2
   #define TUNNEL_DELAY             1
   #define TUNNEL_REST              15

   short index,sign;
   PART *link;

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      /* check to see that the link is still ok */
      if (((link = mouse->toon_link) != 0) && (link->type == PT_TUNNEL))
      {
         /* roughly calculate the distance between the tunnels and weight it */
         /* to fit the animation timing. */
         /* NOTE: belt_size is doubling for a memory field here. */
         mouse->belt_size =
            (abs(link->scrn_loc.x-link->toon_link->scrn_loc.x)+
            abs(link->scrn_loc.y - link->toon_link->scrn_loc.y)) >>
            TUNNEL_DELAY;

         /* reposition the mouse relative to the tunnel */
         if (mouse->flags2 & F2_FLIP_H_DRAW)
            mouse->loc.x = mouse->scrn_loc.x = link->scrn_loc.x +
               52 - mouse->base_size.x - 16;    /* here link->size is replaced */
                                                /* explicitly */
         else
            mouse->loc.x = mouse->scrn_loc.x = link->scrn_loc.x + 16;

         mouse->loc.y = mouse->scrn_loc.y = link->scrn_loc.y + 20;
         mouse->loc.x <<= SCALE_SHIFT;
         mouse->loc.y <<= SCALE_SHIFT;
      }

      /* kill the original velocity */
      mouse->speed.x = mouse->speed.y = 0;
      character_from_move_to_static(mouse);
   }
   
   mouse->work_var++;
   index = mouse->work_var / TUNNEL_RATE;

   /* check to see if the mouse should delay in the tunnel */
   if (index == COMING_OUT_STATE)
   {
      /* check the length in the delay */
      if (mouse->belt_size)
      {
         /* force the index to be correct */
         mouse->work_var = COMING_OUT_STATE * TUNNEL_RATE;

         mouse->belt_size--;

         /* reposition the mouse off the screen while the mouse is delaying in */
         /* the tunnel. */
         mouse->loc.x =
            mouse->loc.y =
            mouse->old_scrn_loc.x = 
            mouse->old_scrn_loc.y = 
            mouse->scrn_loc.x = 
            mouse->scrn_loc.y = 1000;
         mouse->loc.x <<= SCALE_SHIFT;
         mouse->loc.y <<= SCALE_SHIFT;

         /* force woman scream in tunnel */
         if (mouse->belt_size == 35)
            jtp_sx_play(SX_SID_TUNNEL_HUM,0,0);
      }
      else
      {
         /* force the index to be correct */
         /* NOTE: This skips one frame of the animation (I hope it is not a  */
         /* good one! */
         mouse->work_var = (COMING_OUT_STATE + 1) * TUNNEL_RATE;

         /* check to see that the link is still ok */
         if (((link = mouse->toon_link) != 0) && (link->type == PT_TUNNEL))
         {
            /* reposition the mouse around the exit tunnel */
            link = link->toon_link;
            if (mouse->flags2 & F2_FLIP_H_DRAW)
               mouse->loc.x = mouse->scrn_loc.x = link->scrn_loc.x +
                  52 - mouse->base_size.x - 10;
            else
               mouse->loc.x = mouse->scrn_loc.x = link->scrn_loc.x + 10;

            mouse->loc.y = mouse->scrn_loc.y =
               link->scrn_loc.y + 10;

            mouse->loc.x <<= SCALE_SHIFT;
            mouse->loc.y <<= SCALE_SHIFT;
         }
      }
   }

   if (!(mouse->work_var % TUNNEL_RATE))
   {
      if (index < SID_TUNNEL_NUM_OFFSETS)
      {
         mouse->state = sid_tunnel_os[index][2] + SID_TUNNEL_SEQ;

         /* sets up the correct sign for flip drawing */
         if (mouse->flags2 & F2_FLIP_H_DRAW)
            sign = -1;
         else
            sign = 1;

         mouse->loc.x = mouse->scrn_loc.x += sign * sid_tunnel_os[index][0];
         mouse->loc.y = mouse->scrn_loc.y += sid_tunnel_os[index][1];
         mouse->loc.x <<= SCALE_SHIFT;
         mouse->loc.y <<= SCALE_SHIFT;

         mouse_reinit(mouse);

         if (  (mouse->state == 4 + SID_TUNNEL_SEQ)
            && (mouse->old_state == 3 + SID_TUNNEL_SEQ))
            jtp_sx_play(SX_SID_TUNNEL_HELMET,3,0);
         if (mouse->state == 8 + SID_TUNNEL_SEQ)
            jtp_sx_play(SX_SID_TUNNEL_ZIP,3,0);
         if (  (mouse->state == 16 + SID_TUNNEL_SEQ)
            && (mouse->old_state == 15 + SID_TUNNEL_SEQ))
            jtp_sx_play(SX_SID_TUNNEL_LIGHT,3,0);
         if (mouse->state == 20 + SID_TUNNEL_SEQ)
            jtp_sx_play(SX_SID_TUNNEL_HAT,3,0);
         if (mouse->state == 23 + SID_TUNNEL_SEQ)
            jtp_sx_play(SX_SID_TUNNEL_OUT,3,0);
      }
      else
      {
         /* overwrite preempt */
         character_from_static_to_move(mouse);
         mouse->sub_state = mouse->toon_state = SID_WALK_INDEX;
         mouse->state = SID_WALK_SEQ;
         mouse->work_var = 0;
         mouse->toon_link = 0;

         /* set up the delay */
         mouse->work_var1 = (SID_TUNNEL_INDEX << SID_SHIFT) | TUNNEL_REST;
      }
   }
}

/* * * * *
*
*  void mouse_pencil1(PART *mouse);
*
* * * * */
void mouse_pencil1(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,1,1,2,3,4,5,6,7,8,9,10,11,12,13
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PENCIL1_RATE            2

   PART *link;

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      mouse->speed.y = 0;
      
      /* check to see that the link is still ok */
      if (((link = mouse->toon_link) != 0) && (link->type == PT_PENCIL))
      {
         kill_character(link);
         mouse->toon_link = 0;
      }
   }
   
   mouse->speed.x = 0;
   if (!(++mouse->work_var % PENCIL1_RATE))
   {
      if (mouse->work_var < NUM_STATES * PENCIL1_RATE)
      {
         mouse->state = state_array[mouse->work_var / PENCIL1_RATE] - 1 +
            SID_PENCIL1_SEQ;
         mouse_reinit(mouse);

         if (  (mouse->state == 1 + SID_PENCIL1_SEQ)
            || (mouse->state == 4 + SID_PENCIL1_SEQ)
            || (mouse->state == 7 + SID_PENCIL1_SEQ)
            || (mouse->state == 10 + SID_PENCIL1_SEQ))
            jtp_sx_play(SX_SID_PENCIL1,2,0);
      }
      else
         mouse->sub_state = SID_PENCIL2_INDEX;
   }
}

/* * * * *
*
*  void mouse_pencil2(PART *mouse);
*
* * * * */
void mouse_pencil2(PART *mouse)
{
   #define PENCIL2_SLIDE_SPEED      SIXTEEN_PIX
   #define PENCIL2_MIN_DISTANCE     55
   #define PENCIL2_DIST_X           600

   short cat_mid_x,mouse_mid_x;
   PART *pptr,*cat;

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      jtp_sx_play(SX_SID_PENCIL2,2,0);

      /* kill the original velocity */
      mouse->speed.x = mouse->speed.y = 0;

      /* observe the surroundings to see if a cat is near */
      tn_query_dist(mouse,F1_MOVE_L,-PENCIL2_DIST_X,0,
         (PENCIL2_DIST_X<<1)+mouse->size.x,mouse->size.y);

      pptr = mouse->qptr;
      cat = 0;
      while (pptr)
      {
         /* check if the pptr part is a cat */
         if (pptr->type == PT_AL_CAT)
         {
            cat = pptr;
            pptr = 0;
         }
         else
            pptr = pptr->qptr;
      }

      /* set up the jump parameters */
      if (cat)
      {
         /* link the cat to the mouse */
         mouse->toon_link = cat;
         
         /* orient the mouse to jump at the cat */
         if (cat->scrn_loc.x < mouse->scrn_loc.x)
         {
            if (mouse->flags2 & F2_FLIP_H_DRAW)
               sid_flip(mouse, F2_FLIP_H_DRAW);
         }
         else
         {
            if (!(mouse->flags2 & F2_FLIP_H_DRAW))
               sid_flip(mouse, F2_FLIP_H_DRAW);
         }
      }
   }

   ++mouse->work_var;

   /* check the toon link  */
   if (  ((cat = mouse->toon_link) != 0)
      && (cat->type == PT_AL_CAT))
   {
      cat_mid_x = cat->scrn_loc.x + (cat->base_size.x>>1);
      mouse_mid_x = mouse->scrn_loc.x + (mouse->base_size.x>>1);

      /* check if the distance between the cat and the mouse is too  */
      /* large to go into the next mouse pencil sequence. */
      if (abs(mouse_mid_x - cat_mid_x) > PENCIL2_MIN_DISTANCE)
      {
         /* animate the mouse hopping over to the cat */
         if (mouse->state == SID_PENCIL2_SEQ)
            mouse->state++;
         else
            mouse->state--;
         mouse_reinit(mouse);

         /* check if the cat is on the left of the mouse */
         if (cat_mid_x < mouse_mid_x)
            mouse->speed.x = -PENCIL2_SLIDE_SPEED;
         else
            mouse->speed.x = PENCIL2_SLIDE_SPEED;
      }
      else
      {
         mouse->sub_state = SID_PENCIL3_INDEX;
         mouse->speed.x = 0;
      }
   }
   else
   {
      /* overwrite the current sequence. */
      mouse->sub_state = mouse->toon_state = SID_PENCIL4_INDEX;
      mouse->state = SID_PENCIL4_SEQ;
      mouse->work_var = 0;
      return;
   }
}

/* * * * *
*
*  void mouse_pencil3(PART *mouse);
*
* * * * */
void mouse_pencil3(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2,2,2,2,2,2,2,2,2,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,2,3,4,5,5,5,5,5,5,5,
      5,5,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,23,24,24,25,26,
      26,27,27,27,27,26,26,26,25,25,25,24,24,24,25,25,25,26,26,26,25,25,25,
      25,25,25,25,25,28,28,28,28,28,28,28,28,29,30,31,32,23,23,24,24,25,26,26,
      27,27,27,27,26,26,26,25,25,25,24,24,24,25,25,25,26,26,26,25,25,25,28,28,
      28,28,28,28,28,28,29,33,33,33,33,34,34,35
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   PART *link;

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      jtp_sx_play(SX_SID_PENCIL3_1,3,0);

      /* kill the original velocity */
      mouse->speed.x = mouse->speed.y = 0;

      /* check if the toon link is still ok */
      if (((link = mouse->toon_link) != 0) && (link->type == PT_AL_CAT))
         /* get rid of the soon to be popped cat. */
         kill_character(link);
   }
   
   /* check if the mouse has begun to roll */
   if (mouse->flags1 & F1_ROLLING)
      mouse->speed.x = 0;

   if (++mouse->work_var < NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] - 1 + SID_PENCIL3_SEQ;
      mouse_reinit(mouse);

      if (  (mouse->state == 5 + SID_PENCIL3_SEQ)
         || (mouse->state == 8 + SID_PENCIL3_SEQ)
         || (mouse->state == 11 + SID_PENCIL3_SEQ))
         jtp_sx_play(SX_SID_PENCIL3_2,3,0);
      if (mouse->state == 18 + SID_PENCIL3_SEQ)
         jtp_sx_play(SX_SID_PENCIL3_3,3,0);
      if (mouse->state == 23 + SID_PENCIL3_SEQ)
         jtp_sx_play(SX_SID_PENCIL3_4,3,0);
      if (mouse->state == 32 + SID_PENCIL3_SEQ)
         jtp_sx_play(SX_SID_PENCIL3_5,3,0);
   }
   else
      mouse->sub_state = SID_ROOT_INDEX;
}

/* * * * *
*
*  void mouse_pencil4(PART *mouse);
*
* * * * */
void mouse_pencil4(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PENCIL4_RATE            2

   if (!mouse->work_var)
   {
      jtp_sx_play(SX_SID_PENCIL4_1,1,0);
      jtp_sx_play(SX_SID_PENCIL4_2,1,0);
   }

   if (!(++mouse->work_var % PENCIL4_RATE))
   {
      if (mouse->work_var < NUM_STATES * PENCIL4_RATE)
      {
         mouse->state = state_array[mouse->work_var / PENCIL4_RATE] - 1 +
            SID_PENCIL4_SEQ;
         mouse_reinit(mouse);

         if (  (mouse->state ==  3 + SID_PENCIL4_SEQ)
            || (mouse->state ==  6 + SID_PENCIL4_SEQ)
            || (mouse->state ==  9 + SID_PENCIL4_SEQ)
            || (mouse->state ==  12 + SID_PENCIL4_SEQ)
            || (mouse->state ==  15 + SID_PENCIL4_SEQ))
            jtp_sx_play(SX_SID_PENCIL4_2,1,0);
      }
      else
         mouse->sub_state = SID_ROOT_INDEX;
   }
}

/* * * * *
*            
*  void mouse_headless(PART *mouse);
*
* * * * */
void mouse_headless(PART *mouse)
{
   const static char far state_array[] =
   {
      1,2,3,2,2,1,1,2,2,
      1,1,2,2,1,2,
      1,1,2,3,2,2,3,2,2,1,1,4,4,4,4,4,5,5,6
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   /* check for the first time into this sequence */
   if (!mouse->work_var)
      character_from_move_to_static(mouse);
   
   if (++mouse->work_var < NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] - 1 + SID_HEADLESS_SEQ;
      mouse_reinit(mouse);

      if (mouse->state == 4 + SID_HEADLESS_SEQ)
         jtp_sx_play(SX_SID_HEADLESS,1,0);
   }
   else
      if (mouse->work_var == NUM_STATES)
         character_from_static_to_move(mouse);

   /* kill the borders */
   mouse->border = 0;
}

/* * * * *
*
*  void mouse_peel(PART *mouse);
*
* * * * */
void mouse_peel(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,2,3,4,5,6,7
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PEEL_RATE       2
   #define SLIP            2
   
   PART *link;

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      jtp_sx_play(SX_SID_PEEL,0,0);

      /* check if the link is still o.k. */
      if (((link = mouse->toon_link) != 0) && (link->type == PT_BANANA))
      {
         mouse->toon_link = 0;
         kill_character(link);
      }
   }

   /* give the mouse some velocity */
   if (abs(mouse->speed.x) < TWO_PIX)
   {
      if (mouse->flags2 & F2_FLIP_H_DRAW)
         mouse->speed.x += FIVE_PIX;
      else
         mouse->speed.x -= FIVE_PIX;
   }
   
   if (!(++mouse->work_var % PEEL_RATE))
   {
      if (mouse->work_var < NUM_STATES * PEEL_RATE)
      {
         mouse->state = state_array[mouse->work_var / PEEL_RATE] - 1 +
            SID_PEEL_SEQ;
         mouse_reinit(mouse);
      }
      else
      {
         jtp_sx_play(SX_SID_PEEL,0,0);
         mouse->work_var = SLIP * PEEL_RATE;
      }
   }
}

/* * * * *
*
*  void mouse_banana(PART *mouse);
*
* * * * */
void mouse_banana(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,7,7,8,8,8,8,8,8,8,
      9,9,9,9,9,10,10,10,11,12,13,14,15,16,15,16,15,16,15,16
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define BANANA_RATE     2
   #define RELEASE_BANANA  14
   #define SLIP            2
   
   PART *link;

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      /* check if the link is still o.k. */
      if (((link = mouse->toon_link) != 0) && (link->type == PT_BANANA))
         kill_character(link);
   }

   if (!(++mouse->work_var % BANANA_RATE))
   {
      if (mouse->work_var < NUM_STATES * BANANA_RATE)
      {
         mouse->state = state_array[mouse->work_var / BANANA_RATE] - 1 +
            SID_BANANA_SEQ;
         mouse_reinit(mouse);

         /* check if the banana should be released into the air */
         if ((mouse->state == RELEASE_BANANA + SID_BANANA_SEQ) &&
            (mouse->old_state == RELEASE_BANANA - 1 + SID_BANANA_SEQ))
         {
            /* check if the link is still o.k. */
            if (((link = mouse->toon_link) != 0) && (link->type == PT_BANANA))
            {
               mouse->toon_link = 0;

               /* resurrect the banana as a peel */
               link->flags2 &= F2_INACTIVE ^ 0xffff;
               link->state = BANANA_PEEL;
               if (mouse->flags2 & F2_FLIP_H_DRAW)
               {
                  link->loc.x = link->scrn_loc.x =
                     mouse->scrn_loc.x + mouse->base_size.x -
                     (mouse->size.x + mouse->offset.x + 91);
                  link->speed.x = -FOUR_PIX;
               }
               else
               {
                  link->loc.x = link->scrn_loc.x = mouse->scrn_loc.x + 91;
                  link->speed.x = FOUR_PIX;
               }

               link->loc.y = link->scrn_loc.y = mouse->scrn_loc.y + 15;
               link->speed.y = -FIVE_PIX;
               link->loc.x <<= SCALE_SHIFT;
               link->loc.y <<= SCALE_SHIFT;
               banana_reinit(link);
            }
         }

         if (  (mouse->state == 1 + SID_BANANA_SEQ)
            && (mouse->old_state == SID_BANANA_SEQ))
            jtp_sx_play(SX_SID_BANANA_HUM,1,0);
         if (  (mouse->state == 8 + SID_BANANA_SEQ)
            && (mouse->old_state == 7 + SID_BANANA_SEQ))
            jtp_sx_play(SX_SID_BANANA_SQUEEZE,1,0);
         if (  (mouse->state == 9 + SID_BANANA_SEQ)
            && (mouse->old_state == 8 + SID_BANANA_SEQ))
            jtp_sx_play(SX_SID_BANANA_THROW,1,1);
         if (mouse->state > 9 + SID_BANANA_SEQ)
            jtp_sx_play(SX_SID_BANANA_SMACK,1,1);
      }
      else
      {
         /* force the preemption of the toon state */
         mouse->sub_state = mouse->toon_state = SID_ROOT_INDEX;
         mouse->state = SID_ROOT_SEQ;
         mouse->work_var = 0;
      }
   }
}

/* * * * *
*
*  void mouse_bubble(PART *mouse);
*
* * * * */
void mouse_bubble(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define BUBBLE_RATE            2

   if (!mouse->work_var)
      jtp_sx_play(SX_SID_BUBBLE,3,0);

   if (!(++mouse->work_var % BUBBLE_RATE))
   {
      if (mouse->work_var < NUM_STATES * BUBBLE_RATE)
      {
         mouse->state = state_array[mouse->work_var / BUBBLE_RATE] - 1 +
            SID_BUBBLE_SEQ;
         mouse_reinit(mouse);
      }
   }
}

/* * * * *
*
*  void mouse_bubble2(PART *mouse);
*
* * * * */
void mouse_bubble2(PART *mouse)
{
   const static char far state_array[] =
   {
      1,1,1,1,1,1,1,1,1,1,2,2,2,2,3,3,2,2,1,1,3,3,3,3,2,1,1,1,1,3,3,2,1,2,2,2,
      3,3,3,3,3,3,3,3,3,3,4,5,6,7,8,9,10,11,4,5,6,7,8,9,10,11,12,13,14,15,16
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define BUBBLE2_RATE    1
   
   if (!mouse->work_var)
      jtp_sx_play(SX_SID_BUBBLE2_HIT,3,0);

   if (++mouse->work_var < NUM_STATES * BUBBLE2_RATE)
   {
      mouse->state = state_array[mouse->work_var / BUBBLE2_RATE] - 1 +
         SID_BUBBLE2_SEQ;
      mouse_reinit(mouse);

      if (mouse->state == 2 + SID_BUBBLE2_SEQ)
         jtp_sx_play(SX_SID_BUBBLE2_STRETCH,3,1);
      if (mouse->state == 3 + SID_BUBBLE2_SEQ)
         jtp_sx_play(SX_SID_BUBBLE2_SHAKE,1,0);
   }
   else
      mouse->sub_state = SID_ROOT_INDEX;
}

/* * * * *
*
*  void mouse_egg(PART *mouse);
*
* * * * */
void mouse_egg(PART *mouse)
{
   PART *toon_link;

   const static char far state_array[] =
   {
      1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,7,19,20,21,22,23,24,25,
      26,27,28,29,30,31,32,33,22,23,24,25,26,34,
      35,36,37,38,39,40,40,41,41,42,42,43,43
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      if (((toon_link = mouse->toon_link) != 0) && (toon_link->type==PT_EGG))
      {
         kill_character(toon_link);
         mouse->toon_link = 0;
      }
   }
   
   if (++mouse->work_var < NUM_STATES)
   {
      mouse->state = state_array[mouse->work_var] - 1 + SID_EGG_SEQ;
      mouse_reinit(mouse);

      if (mouse->state == SID_EGG_SEQ)
         jtp_sx_play(SX_SID_EGG_CRACK,2,0);
      if (mouse->state == 4 + SID_EGG_SEQ)
         jtp_sx_play(SX_SID_EGG_BIRDS,1,0);
      if (mouse->state == 39 + SID_EGG_SEQ)
         jtp_sx_play(SX_SID_EGG_CLAP,1,0);
   }
   else
      mouse->sub_state = SID_ROOT_INDEX;
}

#if 0
/* * * * *
*
*  void mouse_(PART *mouse);
*
* * * * */
void mouse_(PART *mouse)
{
   const static char far state_array[] =
   {
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define RATE            2

   /* check for the first time into this sequence */
   if (!mouse->work_var)
   {
      /* kill the original velocity */
      mouse->speed.x = mouse->speed.y = 0;
   }
   
   ++mouse->work_var;
   if (!(mouse->work_var % RATE))
   {
      if (mouse->work_var < NUM_STATES * RATE)
      {
         mouse->state = state_array[mouse->work_var / RATE] - 1 +
            SID__SEQ;
         update_character_position(mouse,ALIGN_DOWN);
         mouse_reinit(mouse);
      }
      else
      {
         mouse->sub_state = ;
      }
   }
}
#endif


