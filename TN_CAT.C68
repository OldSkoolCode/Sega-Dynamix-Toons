/* * * * *
*
*  TN_CAT.C
*
*  This module contains code associated with the Al cat character of toons.
*  It does not contain the data structures defining the artwork of the
*  character.
*
*  By Chris Cole -- (c) 1993 Dynamix Software Development, Inc.
*
*  Modification History:
*  ---------------------
*  05/15/93 ChrisC   File created
*
* * * * */
#include "vm.h"
#include "tim.h"
#include "simlib.h"
#include <string.h>

extern PART_BORDER far cat_place_border[CAT_BORDERS];
extern PART_BORDER far cat_place_fborder[CAT_BORDERS];

/* * * * *
*
*  local function to this module
*
* * * * */
void cat_fight_sx(void);
void cat_spin_sx(void);
void cat_tunnel_crash_sx(void);
short cat_observation(PART *cat);
short cat_query_switch(PART *cat, PART *pptr);
void cat_sleep(PART *cat);
void cat_bomb(PART *cat);
void cat_shake(PART *cat);
void cat_crack(PART *cat);
void cat_walk(PART *cat);
void cat_run(PART *cat);
void cat_root(PART *cat);
void cat_hair(PART *cat);
void cat_birds(PART *cat);
void cat_flail(PART *cat);
void cat_shot(PART *cat);
void cat_angel(PART *cat);
void cat_spin(PART *cat);
void cat_skid(PART *cat);
void cat_ate(PART *cat);
void cat_runaw(PART *cat);
void cat_spinaw(PART *cat);
void cat_take(PART *cat);
void cat_climb(PART *cat);
void cat_cut(PART *cat);
void cat_stop(PART *cat);
void cat_hit_floor(PART *cat);
void cat_hit_ceiling(PART *cat);
void cat_hit_left_wall(PART *cat);
void cat_hit_right_wall(PART *cat);
void cat_slide1(PART *cat);
void cat_slide2(PART *cat);
void cat_slide3(PART *cat);
void cat_slide4(PART *cat);
void cat_pin1(PART *cat);
void cat_pin2(PART *cat);
void cat_pin3(PART *cat);
void cat_vac1(PART *cat);
void cat_vac2(PART *cat);
void cat_vac3(PART *cat);
void cat_piano(PART *cat);
void cat_gum(PART *cat);
void cat_lunch(PART *cat);
void cat_tunnel(PART *cat);
void cat_pencil1(PART *cat);
void cat_pencil2(PART *cat);
void cat_pencil4(PART *cat);
void cat_butt(PART *cat);
void cat_fish(PART *cat);
void cat_hairdryer(PART *cat);
void cat_peel(PART *cat);
void cat_banana(PART *cat);
void cat_rug(PART *cat);
void cat_gum2(PART *cat);
void cat_gum3(PART *cat);
void cat_egg(PART *cat);
void cat_pounce(PART *cat);
void cat_yarn(PART *cat);
void cat_scratch(PART *cat);

/* Define data tables that help make the code smaller */
struct cat_tables
{
   short index2seq;
   void (* cat_func) (PART *);
} const cat_tables[CAT_NUM_STATES] =
{
   CAT_ROOT_SEQ,                    cat_root,
   CAT_SLEEP_SEQ,                   cat_sleep,
   CAT_BOMB_SEQ,                    cat_bomb,
   CAT_WALK_SEQ,                    cat_walk,
   CAT_CRACK_SEQ,                   cat_crack,
   CAT_SHAKE_SEQ,                   cat_shake,
   CAT_RUN_SEQ,                     cat_run,
   CAT_HAIR_SEQ,                    cat_hair,
   CAT_BIRDS_SEQ,                   cat_birds,
   CAT_FLAIL_SEQ,                   cat_flail,
   CAT_UNUSED1_SEQ,                 0,
   CAT_UNUSED2_SEQ,                 0,
   CAT_UNUSED3_SEQ,                 0,
   CAT_UNUSED4_SEQ,                 0,
   CAT_POUNCE_SEQ,                  cat_pounce,
   CAT_YARN_SEQ,                    cat_yarn,
   CAT_SHOT_SEQ,                    cat_shot,
   CAT_ANGEL_SEQ,                   cat_angel,
   CAT_SPIN_SEQ,                    cat_spin,
   CAT_SKID_SEQ,                    cat_skid,
  -CAT_ATE_SEQ,                     cat_ate,
   CAT_RUNAW_SEQ,                   cat_runaw,
   CAT_SPINAW_SEQ,                  cat_spinaw,
   CAT_TAKE_SEQ,                    cat_take,
  -CAT_CLIMB_SEQ,                   cat_climb,
  -CAT_CUT_SEQ,                     cat_cut,
   CAT_STOP_SEQ,                    cat_stop,
   CAT_HIT_FLOOR_SEQ,               cat_hit_floor,
   CAT_HIT_CEILING_SEQ,             cat_hit_ceiling,
   CAT_HIT_LEFT_WALL_SEQ,           cat_hit_left_wall,
   CAT_HIT_RIGHT_WALL_SEQ,          cat_hit_right_wall,
   CAT_SLIDE1_SEQ,                  cat_slide1,
   CAT_SLIDE2_SEQ,                  cat_slide2,
   CAT_SLIDE3_SEQ,                  cat_slide3,
   CAT_SLIDE4_SEQ,                  cat_slide4,
   CAT_PIN1_SEQ,                    cat_pin1,
   CAT_PIN2_SEQ,                    cat_pin2,
   CAT_PIN3_SEQ,                    cat_pin3,
   CAT_VAC1_SEQ,                    cat_vac1,
   CAT_VAC2_SEQ,                    cat_vac2,
   CAT_VAC3_SEQ,                    cat_vac3,
   -CAT_PIANO_SEQ,                  cat_piano,
   CAT_GUM_SEQ,                     cat_gum,
   CAT_BUTT_SEQ,                    cat_butt,
   CAT_LUNCH_SEQ,                   cat_lunch,
   CAT_TUNNEL_SEQ,                  cat_tunnel,
   CAT_PENCIL1_SEQ,                 cat_pencil1,
   CAT_PENCIL2_SEQ,                 cat_pencil2,
   CAT_SCRATCH_SEQ,                 cat_scratch,
   CAT_PENCIL4_SEQ,                 cat_pencil4,
   CAT_FISH_SEQ,                    cat_fish,
   CAT_HAIRDRYER_SEQ,               cat_hairdryer,
   CAT_MIRROR1_SEQ,                 0,
   CAT_MIRROR2_SEQ,                 0,
   CAT_PEEL_SEQ,                    cat_peel,
   CAT_BANANA_SEQ,                  cat_banana,
   CAT_RUG_SEQ,                     cat_rug,
   CAT_GUM2_SEQ,                    cat_gum2,
   CAT_GUM3_SEQ,                    cat_gum3,
   CAT_EGG_SEQ,                     cat_egg,
   CAT_NUM_STATES,                  0
};

/* * * * *
*
*  cat global and local variables and defines.
*
* * * * */
CHAR cat_bord_num;

#define CAT_FALLING              THREE_PIX<<VIRTUALCOORDS
#define CAT_FALL_THRESHOLD1      ONE_PIX<<VIRTUALCOORDS
#define CAT_FALL_THRESHOLD2      TWO_PIX<<VIRTUALCOORDS
#define CAT_FALL_THRESHOLD3      THREE_PIX<<VIRTUALCOORDS
#define CAT_FALL_THRESHOLD4      FOUR_PIX<<VIRTUALCOORDS
#define CAT_FALL_THRESHOLD5      EIGHT_PIX<<VIRTUALCOORDS
#define CAT_SHIFT                8
#define CAT_RUN_DELAY            15
#define CAT_GUM_FLOAT_STATE      (27 + CAT_GUM_SEQ)
#define CAT_HAIRDRYER_FLOAT_STATE (2 + CAT_HAIRDRYER_SEQ)
              


/* * * * *
*
*  void al_cat_reinit(PART *cat);
*
*  This function will reinitiallize the borders of the cat character.
*
* * * * */
void al_cat_reinit(PART *cat)
{
   /* If initalizing for the first time, create flip borders */
   if(!cat)
   {
      set_border_slopes(PT_AL_CAT, 0, cat_place_border, 0, 0);
      set_border_slopes(PT_AL_CAT, 0, cat_root_border, 0, 0);
      return;
   }
   
   /* Setup border pointer for cat */
   if(!cat->state && (tim_mode != TM_RUN))
   {
         cat->border = cat_place_border;
   }
   else
      cat->border = cat_root_border;
   set_adjusted_loc_size(cat);
}



/* * * * *
*
*  void cat_flip(PART *cat, SHORT flip_mode);
*
* * * * */
#pragma argsused
void cat_flip(PART *cat, SHORT flip_mode)
{
   cat->flags2 ^= F2_FLIP_H_DRAW;
   al_cat_reinit(cat);
   part_to_er(cat,1|2);
   set_redraw(cat,2);
}


/* * * * *
*
*  short al_cat_collide(PART *cur_part);
*
*  This is the main collision rountine.
*
* * * * */
short al_cat_collide(PART *cur_part)
{
   PART *cat;
   short slope,speed_x,speed_y,old_speed_y;
   short cat_mid_y, part_mid_y;
   short cat_mid_x, part_mid_x;

   /* assigns the pointers to the correct parts. */
   if (cur_part->type == PT_AL_CAT)
   {
      cat = cur_part;
      cur_part = cur_part->col_info.part;
      slope = cat->col_info.slope;
   }
   else
   {
      cat = cur_part->col_info.part;
      slope = cur_part->col_info.slope;
   }

   /* calculate the relative speeds of the two colliding parts. */
   speed_x = cat->speed.x - cur_part->speed.x;
   speed_y = cat->speed.y - cur_part->speed.y;
   old_speed_y = cat->speed.y;

   /* calculate the midpoints of the two parts */
   cat_mid_x = cat->scrn_loc.x + (cat->base_size.x >> 1);
   cat_mid_y = cat->scrn_loc.y + (cat->base_size.y >> 1);
   part_mid_x = cur_part->scrn_loc.x + (cur_part->size.x >> 1);
   part_mid_y = cur_part->scrn_loc.y + (cur_part->size.y >> 1);

   /* special check to see if the cat is supported on the end of wall */
/*   if (  !slope */
/*      && (cat->flags1 & F1_ROLLING) */
/*      && (abs(speed_x) < ONE_PIX)) */
/*      cat->speed.x = 0; */

   /* check for hitting cases */
   if (  (cat->sub_state == -1)
      && !(cat->flags1 & F1_ROLLING))
   {
      switch (slope)
      {
         case 0x0000:
            if (speed_y > CAT_FALL_THRESHOLD2)
               cat->sub_state = CAT_HIT_FLOOR_INDEX;
            break;
         case -0x8000:
            if (speed_y < -CAT_FALL_THRESHOLD1)
               cat->sub_state = CAT_HIT_CEILING_INDEX;
            break;
         case 0x4000:
            if (speed_x > TWO_PIX)
            {
               if (!(cat->flags2 & F2_FLIP_H_DRAW))
                  cat->sub_state = CAT_HIT_RIGHT_WALL_INDEX;
               else
                  cat->sub_state = CAT_HIT_LEFT_WALL_INDEX;
            }
            break;
         case -0x4000:
            if (speed_x < -TWO_PIX)
            {
               if (!(cat->flags2 & F2_FLIP_H_DRAW))
                  cat->sub_state = CAT_HIT_LEFT_WALL_INDEX;
               else
                  cat->sub_state = CAT_HIT_RIGHT_WALL_INDEX;
            }
            break;
      }
   }
   
   switch (cat->toon_state)
   {
      case CAT_RUN_INDEX:
      case CAT_RUNAW_INDEX:
         switch (slope)
         {
            case 0x4000:
               if (!(cat->flags2 & F2_FLIP_H_DRAW))
                  cat->sub_state = CAT_HIT_RIGHT_WALL_INDEX;
               else
                  cat->sub_state = CAT_HIT_LEFT_WALL_INDEX;
               break;
            case -0x4000:
               if (!(cat->flags2 & F2_FLIP_H_DRAW))
                  cat->sub_state = CAT_HIT_LEFT_WALL_INDEX;
               else
                  cat->sub_state = CAT_HIT_RIGHT_WALL_INDEX;
               break;
         }
         goto DEFAULT_COLLIDE_CHECK;
      case CAT_WALK_INDEX:
         if ((slope == 0x4000) || (slope == -0x4000))
         {
            cat->sub_state = CAT_ROOT_INDEX;
            cat->speed.x = 0;
         }
         goto DEFAULT_COLLIDE_CHECK;
      case CAT_GUM_INDEX:
         /* check if sid is floating up with the gum. */
         if (cat->state == CAT_GUM_FLOAT_STATE)
         {
            /* make sure nothing improper will change the state of the cat */
            cat->sub_state = -1;

            switch (cur_part->type)
            {
               case PT_HATPIN:
                  /* check the hatpin is vertically orientated */
                  if (!cur_part->state)
                  {
                     /* check if the hatpin is oriented with the tip down */
                     if (cur_part->flags2 & F2_FLIP_V_DRAW)
                     {
                        if (cat_mid_y > part_mid_y)
                           cat->sub_state = CAT_GUM2_INDEX;
                     }
                     else
                     {
                        if (cat_mid_y < part_mid_y)
                           cat->sub_state = CAT_GUM2_INDEX;
                     }
                  }
                  else
                  {
                     /* check if the hatpin is oriented with the tip left */
                     if (cur_part->flags2 & F2_FLIP_H_DRAW)
                     {
                        if (cat_mid_x < part_mid_x)
                           cat->sub_state = CAT_GUM2_INDEX;
                     }
                     else
                     {
                        if (cat_mid_x > part_mid_x)
                           cat->sub_state = CAT_GUM2_INDEX;
                     }
                  }
                  break;
               case PT_GEAR:
                  /* check if the gear is moving */
                  if (cur_part->state != cur_part->old_state)
                     cat->sub_state = CAT_GUM2_INDEX;
                  break;
               case PT_SCISSORS:
                  /* check if the scissors is facing left */
                  if (cur_part->flags2 & F2_FLIP_H_DRAW)
                  {
                     if (cat_mid_x > part_mid_x)
                        cat->sub_state = CAT_GUM2_INDEX;
                  }
                  else
                  {
                     if (cat_mid_x < part_mid_x)
                        cat->sub_state = CAT_GUM2_INDEX;
                  }
                  break;
               case PT_BULLET:
                  cat->sub_state = CAT_GUM2_INDEX;
                  break;
            }
         }
         break;
      case CAT_GUM2_INDEX:
         cat->sub_state = CAT_GUM3_INDEX;
         break;
      case CAT_HAIRDRYER_INDEX:
         /* check if Al is floating up with the gum. */
         if (cat->state == CAT_HAIRDRYER_FLOAT_STATE)
            cat->sub_state = CAT_SHAKE_INDEX;
         break;
      case CAT_PIN3_INDEX:
         cat->sub_state = CAT_BUTT_INDEX;
         break;
      case CAT_FLAIL_INDEX:
         if ((cat->sub_state == -1) ||
            (cat->sub_state == CAT_HIT_FLOOR_INDEX))
         {
            if (cat->speed.y < CAT_FALL_THRESHOLD2)
               cat->sub_state = CAT_ROOT_INDEX;
            else if (cat->speed.y < CAT_FALL_THRESHOLD5)
               cat->sub_state = CAT_HIT_FLOOR_INDEX;
            else
               cat->sub_state = CAT_CRACK_INDEX;
            cat->speed.y = 0;
         }
         goto DEFAULT_COLLIDE_CHECK;
      case CAT_SLIDE1_INDEX:
      case CAT_SLIDE2_INDEX:
      case CAT_SLIDE3_INDEX:
      case CAT_SLIDE4_INDEX:
         switch (cur_part->type)
         {
            case PT_INCLINE1:
            case PT_INCLINE2:
            case PT_INCLINE3:
            case PT_INCLINE4:
            case PT_INCLINE5:
               break;
            default:
               if (cat->sub_state == -1)
                  cat->sub_state = CAT_ROOT_INDEX;
         }
         goto DEFAULT_COLLIDE_CHECK;
      case CAT_POUNCE_INDEX:
         if ((slope == 0x4000) || (slope == -0x4000))
            cat->speed.x = 0;
         else if ((cat->state > CAT_POUNCE_SEQ + 1) && (cat->sub_state == -1))
            cat->sub_state = CAT_ROOT_INDEX;
         goto DEFAULT_COLLIDE_CHECK;
      case CAT_RUG_INDEX:
      case CAT_PIN1_INDEX:
      case CAT_PIN2_INDEX:
         if (cat->sub_state == -1)
            cat->sub_state = CAT_ROOT_INDEX;
         goto DEFAULT_COLLIDE_CHECK;
      default:
DEFAULT_COLLIDE_CHECK:
         cat->speed.y = 0;
         switch (cur_part->type)
         {
            case PT_SID_MOUSE:
               /* force the collision between the two characters to go through */
               /* the same function. */
               character_collision(cat,cur_part);
               break;
            case PT_BOMB:
            case PT_ROCK:
            case PT_ANVIL:
               if (abs(speed_y) > CAT_FALL_THRESHOLD3)
                  cat->sub_state = CAT_CRACK_INDEX;
               break;
            case PT_TEAPOT:
            case PT_SOCCER:
               if (abs(speed_y) > CAT_FALL_THRESHOLD3)
                  cat->sub_state = CAT_HIT_FLOOR_INDEX;
               break;
            case PT_BEACHBALL:
               if (abs(speed_y) > CAT_FALL_THRESHOLD2)
                  cat->sub_state = CAT_SHAKE_INDEX;
               break;
            case PT_BASEBALL:
            case PT_CAT_EYE_M:
            case PT_BOULDER_M:
            case PT_STEELY_M:
            case PT_PEE_WEE_M:
            case PT_STRIPE_M:
               if (abs(speed_y) > CAT_FALL_THRESHOLD2)
                  cat->sub_state = CAT_BIRDS_INDEX;
               break;
            case PT_DUSTBUNNY:
               if (preempt_cat(cat))
               {
                  kill_character(cur_part);
                  cat->sub_state = CAT_HAIR_INDEX;
               }
               break;
            case PT_HAIR_BALL:
               cat->sub_state = CAT_HAIR_INDEX;
               break;
            case PT_BULLET:
               cat->speed.x = 0;

               /* check if the bullet hit Al from behind */
               if (  (!(cur_part->flags2 & F2_FLIP_H_DRAW)
                  && !(cat->flags2 & F2_FLIP_H_DRAW))
                  || ((cur_part->flags2 & F2_FLIP_H_DRAW)
                  && (cat->flags2 & F2_FLIP_H_DRAW)))
                  cat->sub_state = CAT_BUTT_INDEX;
               else
                  cat->sub_state = CAT_SHOT_INDEX;
               break;
            case PT_SCISSORS:
               /* check if the orientation of the scissors to Al is ready for  */
               /* Al to use the scissors */
               if (  (((cat_mid_x > part_mid_x)
                  && (cat->flags2 & F2_FLIP_H_DRAW)
                  && !(cur_part->flags2 & F2_FLIP_H_DRAW))
                  || ((cat_mid_x < part_mid_x)
                  && !(cat->flags2 & F2_FLIP_H_DRAW)
                  && (cur_part->flags2 & F2_FLIP_H_DRAW)))
                  && !cur_part->state
                  && preempt_cat(cat))
               {
                  cat->sub_state = CAT_CUT_INDEX;
                  cat->toon_link = cur_part;
               }

               /* check if the orientation of the scissors to Al is ready to */
               /* poke Al */
               else if (  (cat_mid_x > part_mid_x)
                  && (cur_part->flags2 & F2_FLIP_H_DRAW))
               {
                  if (!(cat->flags2 & F2_FLIP_H_DRAW))
                     cat->sub_state = CAT_PIN3_INDEX;
                  else
                     cat->sub_state = CAT_SHOT_INDEX;
               }

               /* check if the orientation of the scissors to Al is ready to */
               /* poke Al */
               else if (  (cat_mid_x < part_mid_x)
                  && !(cur_part->flags2 & F2_FLIP_H_DRAW))
               {
                  if (cat->flags2 & F2_FLIP_H_DRAW)
                     cat->sub_state = CAT_PIN3_INDEX;
                  else
                     cat->sub_state = CAT_SHOT_INDEX;
               }
               break;
            case PT_YARNBALL:
               /* check if the cat can go for the yarnball */
               if (preempt_cat(cat))
               {
                  /* check if the cat is ready to enter the yarn ball sequence. */
                  if ((cat->toon_state == CAT_POUNCE_INDEX) && (old_speed_y > 0))
                  {
                     cat->sub_state = CAT_YARN_INDEX;
                     cat->toon_link = cur_part;
                  }
                  else if (!old_speed_y)
                  {
                     cat->sub_state = CAT_SCRATCH_INDEX;
                     cat->toon_link = cur_part;
                  }
               }
               break;
            case PT_TRAMP:
               if (old_speed_y > 0)
               {
                  cat->speed.y = old_speed_y;
                  cat->sub_state = CAT_ROOT_INDEX;
               }
               break;
            case PT_INCLINE0:       
            case PT_INCLINE1:       
            case PT_INCLINE2:      
            case PT_INCLINE3:       
            case PT_INCLINE4:
            case PT_INCLINE5:
               /* check if the mouse hit the incline from above */
               if (  (old_speed_y > 0)
                  && preempt_cat(cat)
                  && (cat->scrn_loc.y < cur_part->scrn_loc.y)
                  && ((!(cur_part->flags2 & F2_FLIP_H_DRAW)
                  && cat->col_info.left_of_cog_supported)
                  || ( (cur_part->flags2 & F2_FLIP_H_DRAW)
                  && cat->col_info.right_of_cog_supported)))
               {
                  /* reset the vertical velocity of the cat */
                  cat->speed.y = old_speed_y;

                  /* remember which incline was hit */
                  cat->toon_link = cur_part;

                  /* decide which slide to use. */
                  switch (cur_part->state)
                  {
                     case 3:
                        cat->sub_state = CAT_SLIDE1_INDEX;
                        break;
                     case 2:
                        cat->sub_state = CAT_SLIDE2_INDEX;
                        break;
                     case 1:
                        cat->sub_state = CAT_SLIDE3_INDEX;
                        break;
                     case 0:
                        cat->sub_state = CAT_SLIDE4_INDEX;
                        break;
                  }
               }
               else
                  /* This allows for the richochette off the inclines */
                  cat->speed.y = old_speed_y;
               break;
            case PT_HATPIN:
               /* check if the hatpin is oriented vertically */
               if (!cur_part->state)
               {
                  /* check if the cat hit the tip of the pin */
                  if (!(cur_part->flags2 & F2_FLIP_V_DRAW))
                  {
                     if (  (cat_mid_y < part_mid_y)  &&
                           (old_speed_y > 0))
                     {
                        cat->speed.x = 0;
                        cat->sub_state = CAT_PIN1_INDEX;
                     }
                  }
                  else
                  {
                     if (  (cat_mid_y > part_mid_y)  &&
                           (old_speed_y < 0))
                     {
                        cat->speed.x = 0;
                        cat->sub_state = CAT_PIN2_INDEX;
                     }
                  }
               }
               else
               {
                  /* check if the cat hit the right tip of the pin */
                  if (!(cur_part->flags2 & F2_FLIP_H_DRAW))
                  {
                     if (  (cat_mid_x > part_mid_x)  &&
                           (cat->speed.x < 0))
                     {
                        if (cat->flags2 & F2_FLIP_H_DRAW)
                        {
                           cat->sub_state = CAT_SHOT_INDEX;
                        }
                        else
                           cat->sub_state = CAT_PIN3_INDEX;

                        cat->speed.x = 0;
                     }
                  }
                  else
                  {
                     if (  (cat_mid_x < part_mid_x)  &&
                           (cat->speed.x > 0))
                     {
                        if (!(cat->flags2 & F2_FLIP_H_DRAW))
                        {
                           cat->sub_state = CAT_SHOT_INDEX;
                        }
                        else
                           cat->sub_state = CAT_PIN3_INDEX;

                        cat->speed.x = 0;
                     }
                  }
               }
               break;
            case PT_PIANO:
               /* check if the piano is falling and hitting Al */
               if (  preempt_cat(cat)
                  && cur_part->sub_state
                  && (cur_part->speed.y > 0)
                  && (cat_mid_y > part_mid_y)
                  && (cat_mid_x > part_mid_x - 25)
                  && (cat_mid_x < part_mid_x + 25))
               {
                  cat->sub_state = CAT_PIANO_INDEX;
                  cat->toon_link = cur_part;
               }
               break;
            case PT_GUM:
               if (  (abs(cur_part->speed.y >> SCALE_SHIFT) < 1)
                  && preempt_cat(cat))
               {
                  cat->sub_state = CAT_GUM_INDEX;
                  cat->toon_link = cur_part;
               }
               break;
            case PT_PENCIL:
               if (preempt_cat(cat))
               {
                  cat->sub_state = CAT_PENCIL1_INDEX;
                  cat->toon_link = cur_part;
               }
               break;
            case PT_FISH:
               if (preempt_cat(cat))
               {
                  cat->sub_state = CAT_FISH_INDEX;
                  cat->toon_link = cur_part;
               }
               break;
            case PT_RUG:
               /* check if the collision is in the correct half of the cat */
               if ((cat_mid_x > part_mid_x-10) && (cat_mid_x < part_mid_x+10))
               {
                  cat->sub_state = CAT_RUG_INDEX;
                  cur_part->sub_state = 1;
               }
               break;
            case PT_BANANA:
               if (preempt_cat(cat))
               {
                  if (cur_part->state == BANANA_PEEL)
                  {
                     cat->sub_state = CAT_PEEL_INDEX;
                     cat->toon_link = cur_part;
                  }
                  else
                  {
                     cat->sub_state = CAT_BANANA_INDEX;
                     cat->toon_link = cur_part;
                  }
               }
               break;
            case PT_EGG:
               if (  preempt_cat(cat)
                  && (cur_part->speed.y - cat->speed.y > EGG_THRESHOLD))
               {
                  cat->sub_state = CAT_EGG_INDEX;
                  cat->toon_link = cur_part;
               }
               break;
         }
         break;
   }
   return(1);
}



/* * * * *
*
*  void al_cat_internal(PART *cat);
*
* * * * */
void al_cat_internal(PART *cat)
{
   short temp, old_state;
   PART *toon_link;

   /* If internal function has already been processed, just return */
   if(cat->flags2 & F2_INTERNAL)
      return;
   cat->flags2 |= F2_INTERNAL;

   /* If rolling and falling at the same time, adjust fall speed */
   if((cat->speed.y >= CAT_FALLING) && (cat->flags1 & F1_ROLLING))
      cat->speed.y = CAT_FALLING - 1;

   /* process collision */
   if (  preempt_cat(cat)
      && (cat->sub_state >= 0)
      && (cat->sub_state != cat->toon_state))
   {
      old_state = cat->state;
      switch (cat->sub_state)
      {
         case CAT_GUM2_INDEX:
         case CAT_GUM3_INDEX:
         case CAT_EGG_INDEX:
         case CAT_POUNCE_INDEX:
         case CAT_YARN_INDEX:
         case CAT_SCRATCH_INDEX:
         case CAT_HAIR_INDEX:
            cat->speed.x = cat->speed.y = 0;
            break;
         case CAT_FLAIL_INDEX:
         case CAT_SPINAW_INDEX:
         case CAT_TAKE_INDEX:
            cat->speed.x = 0;
            break;
         case CAT_SLEEP_INDEX:
            cat->toon_link = 0;
            break;
         case CAT_ATE_INDEX:
            /* check if the link is still ok */
            if (((toon_link = cat->toon_link) != 0) &&
               (toon_link->type == PT_SID_MOUSE))
            {
               kill_character(toon_link);
               cat->toon_link = 0;
               cat->state = CAT_ATE_SEQ;
            }
            break;
         case CAT_CLIMB_INDEX:
            if ((cat->work_var1 >> CAT_SHIFT) != CAT_CLIMB_INDEX)
            {
               /* reposition cat on ladder. */
               cat->speed.x = cat->speed.y = 0;

/*               if (cat->flags2 & F2_FLIP_H_DRAW) */
               cat->old_scrn_loc.x = cat->scrn_loc.x = cat->loc.x =
                  cat->toon_link->scrn_loc.x
               + (cat->toon_link->base_size.x - cat->base_size.x)/2;


               cat->loc.x <<= SCALE_SHIFT;
               character_from_move_to_static(cat);
               
               init_part_ladder(cat,CAT_RUN_INDEX, CAT_CLIMB_SEQ,
                  CAT_ROOT_INDEX, CAT_ROOT_SEQ);
            }
            break;
         case CAT_CUT_INDEX:
            /* check if the toon link is still o.k. */
            if (((toon_link = cat->toon_link) != 0) &&
               (cat->toon_link->type == PT_SCISSORS))
            {
               /* repositions the cat to be in the correct location. */
               if (cat->flags2 & F2_FLIP_H_DRAW)
                  cat->loc.x = cat->old_scrn_loc.x =
                     cat->scrn_loc.x = toon_link->scrn_loc.x + 38;
               else
                  cat->loc.x = cat->old_scrn_loc.x =
                     cat->scrn_loc.x = toon_link->scrn_loc.x - 47;

               cat->loc.y = cat->old_scrn_loc.y =
                  cat->scrn_loc.y = toon_link->scrn_loc.y - 2;
               cat->loc.x <<= SCALE_SHIFT;
               cat->loc.y <<= SCALE_SHIFT;

               cat->state = CAT_CUT_SEQ;
            }
            break;
         case CAT_SLIDE1_INDEX:
         case CAT_SLIDE2_INDEX:
         case CAT_SLIDE3_INDEX:
         case CAT_SLIDE4_INDEX:
            /* decide if the toon_link is still good */
            if (((toon_link = cat->toon_link) != 0) &&
               (((toon_link->type >= PT_INCLINE0) &&
               (toon_link->type <= PT_INCLINE4)) ||
               (toon_link->type == PT_INCLINE5)))
            {
               /* check the orientation of the cat to the toon_linked incline */
               if (toon_link->flags2 & F2_FLIP_H_DRAW)
               {
                  if (!(cat->flags2 & F2_FLIP_H_DRAW))
                     cat_flip(cat, F2_FLIP_H_DRAW);

               }
               else
               {
                  if (cat->flags2 & F2_FLIP_H_DRAW)
                     cat_flip(cat, F2_FLIP_H_DRAW);

               }
            }
            break;
         case CAT_PIANO_INDEX:
            /* check if the toon link is still o.k. */
            if (((toon_link = cat->toon_link) != 0) &&
               (cat->toon_link->type == PT_PIANO))
            {
               character_from_move_to_static(cat);
               cat->state = CAT_PIANO_SEQ;
               
               /* orient the cat correctly */
               if (cat->flags2 & F2_FLIP_H_DRAW)
                  cat_flip(cat, F2_FLIP_H_DRAW);

            }
            break;
         case CAT_GUM_INDEX:
            /* orient the mouse to face the gum */
            if (((toon_link = cat->toon_link) != 0) &&
               (toon_link->type == PT_GUM) &&
               (((cat->flags2 & F2_FLIP_H_DRAW) &&
               (cat->scrn_loc.x < cat->toon_link->scrn_loc.x)) ||
               (!(cat->flags2 & F2_FLIP_H_DRAW) &&
               (cat->scrn_loc.x > cat->toon_link->scrn_loc.x))))
               cat_flip(cat, F2_FLIP_H_DRAW);
            break;
         case CAT_TUNNEL_INDEX:
            /* reposition the cat on the tunnel */
            if (((toon_link = cat->toon_link) != 0) &&
               (toon_link->type == PT_TUNNEL))
            {
               if (cat->flags2 & F2_FLIP_H_DRAW)
                  cat->loc.x = cat->old_scrn_loc.x = cat->scrn_loc.x =
                     toon_link->scrn_loc.x + toon_link->base_size.x -
                     cat->base_size.x;
               else
                  cat->loc.x = cat->old_scrn_loc.x = cat->scrn_loc.x =
                     toon_link->scrn_loc.x;

               cat->loc.x <<= SCALE_SHIFT;
            }
            break;
         case CAT_FISH_INDEX:
            /* check if the link is still ok */
            if (((toon_link = cat->toon_link) != 0) &&
               (toon_link->type == PT_FISH))
               cat->speed.x = toon_link->speed.x = 0;
            break;
         case CAT_RUG_INDEX:
            /* reposition the cat to fall through the hole */
            if (((toon_link = cat->toon_link) != 0) &&
               (toon_link->type == PT_RUG))
            {
               cat->loc.x = cat->scrn_loc.x =
                  toon_link->scrn_loc.x - (cat->base_size.x>>1);
               cat->loc.x <<= SCALE_SHIFT;
            }
            cat->speed.x = 0;
            break;
      }

      /* Convert index to a sequence */
      if(cat_tables[cat->sub_state].index2seq >= 0)
         cat->state = cat_tables[cat->sub_state].index2seq;

      /* check if the a new sequence should be initialized. */
      if (cat->state != old_state)
      {
         cat->toon_state = cat->sub_state;
         cat->work_var = 0;
         al_cat_reinit(cat);
      }
   }

   /* reset the sub_state */
   cat->sub_state = -1;

   /* process delay counter */
   /* NOTE: the top 8 bits indicate the toon_state and the bottom 8 bits  */
   /* indicate the counter */
   if (cat->work_var1&0xff00)
   {
      temp = cat->work_var1 & 0x00ff;
      temp--;
      if (temp > 0)
      {
         cat->work_var1 &= 0xff00;
         cat->work_var1 += temp;
      }
      else
         cat->work_var1 = 0;
   }

   /* process animation */
   if(cat_tables[cat->toon_state].cat_func)
      cat_tables[cat->toon_state].cat_func(cat);
}


/* * * * *
*
*  void load_cat_shapes(void);
*
* * * * */
void load_cat_shapes(void)
{
}



/* * * * *
*
*  void free_cat_shape(void);
*
*  This function will free the cat character shapes.
*
* * * * */
void free_cat_shapes(void)
{
}



/* * * * *
*
*  CHAR preempt_cat(PART *cat);
*
*  This function will return 0, if the cat is currently in an animation
*  sequence that should not be interrupted. 1 otherwise.
*
* * * * */
CHAR preempt_cat(PART *cat)
{
   switch (cat->toon_state)
   {
      case CAT_GUM_INDEX:
         if (cat->state == CAT_GUM_FLOAT_STATE)
            return(1);
         else
            return(0);
      case CAT_ATE_INDEX:
      case CAT_CLIMB_INDEX:
      case CAT_TUNNEL_INDEX:
      case CAT_BOMB_INDEX:
      case CAT_CRACK_INDEX:
      case CAT_YARN_INDEX:
      case CAT_SHOT_INDEX:
      case CAT_ANGEL_INDEX:
      case CAT_BANANA_INDEX:
      case CAT_LUNCH_INDEX:
         return(0);
      default:
         return(1);
   }
}

/* * * * *
*
*  void cat_fight_sx(void);
*
* * * * */
void cat_fight_sx(void)
{
   short index, id;

   if (  !jtp_sx_playing(SX_CAT_FIGHT0)
      && !jtp_sx_playing(SX_CAT_FIGHT1)
      && !jtp_sx_playing(SX_CAT_FIGHT2)
      && !jtp_sx_playing(SX_CAT_FIGHT3))
   {
      index = my_random() % 4;
      switch (index)
      {
         case 0:
            id = SX_CAT_FIGHT0;
            break;
         case 1:
            id = SX_CAT_FIGHT1;
            break;
         case 2:
            id = SX_CAT_FIGHT2;
            break;
         default:
            id = SX_CAT_FIGHT3;
            break;
      }
      jtp_sx_play(id,3,0);
   }
}

/* * * * *
*
*  void cat_spin_sx(void);
*
* * * * */
void cat_spin_sx(void)
{
#if ENGLISH
   static const short far state_array[] =
   {
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN0,
      SX_CAT_SPIN1,
      SX_CAT_SPIN1,
      SX_CAT_SPIN1,
      SX_CAT_SPIN2,
      SX_CAT_SPIN2,
      SX_CAT_SPIN2,
      SX_CAT_SPIN3,
      SX_CAT_SPIN4
   };
   #define NUM_SX (sizeof(state_array)/sizeof(short))
   short id;

   /* find the next sx */
   id = state_array[my_random() % NUM_SX];
   jtp_sx_play(id,4,0);

#elif GERMAN || FRENCH
   jtp_sx_play(SX_CAT_SPIN0,4,0);
#endif
}

/* * * * *
*
*  void cat_tunnel_crash_sx(void);
*
* * * * */
void cat_tunnel_crash_sx(void)
{
   short index;
   static const short far crash_array[] =
   {
      3028,3053,3094,3105,3071,3067,3005,3086
   };
   #define CRASH_NUM_STATES   (sizeof(crash_array)/sizeof(short))

   index = my_random() % CRASH_NUM_STATES;
   jtp_sx_play(crash_array[index],0,0);
}

/* * * * *
*
*  short cat_observation(PART *cat);
*
*  This function will set the cat->sub_state variable of the specified part
*  to perform the observation seen. It will also reorient the cat accordingly.
*  It returns the sub_state value assigned.
*
* * * * */
short cat_observation(PART *cat)
{
   #define CAT_X_RANGE              CHARACTER_X_RANGE
   #define CAT_Y_THRESHOLD          10

   PART *pptr;
   short return_val,flip;
   short x,y,w,h;
   short check_left,check_right;
   short cat_mid_x;
   short pptr_mid_x;
   short chasing;

   return_val = -1;
   chasing = 0;

   /* check if the cat is not vertically stable */
   if ((abs(cat->speed.y >> SCALE_SHIFT) > 1) ||
      (cat->scrn_loc.y != cat->old_old_scrn_loc.y) ||
      (run_count < 2))
      return(return_val);

   /* check if the cat still has a valid link */
   if (  ((pptr = cat->toon_link) != 0)
      && !(pptr->flags2 & F2_INACTIVE)
      && (pptr->type == PT_SID_MOUSE)
      && (cat->toon_state != CAT_ROOT_INDEX))
      chasing = 1;

   /* set up query rectangle */
   x = -CAT_X_RANGE;
   y = 0;
   w = (CAT_X_RANGE<<1) + cat->base_size.x;
   h = cat->base_size.y;
   flip = cat->flags2 & F2_FLIP_H_DRAW;
   check_left = check_right = 1;
   cat_mid_x = cat->scrn_loc.x+cat->offset.x+(cat->base_size.x>>1);
   
   /* make the query list of visable objects */
   tn_query_dist(cat,F1_STATIC_L|F1_MOVE_L,x,y,w,h);
   pptr = cat->qptr;
   while (pptr)
   {
      /* check if the cat is chasing the mouse */
      if (chasing)
      {
         switch (pptr->type)
         {
            case PT_LADDER:
            case PT_TUNNEL:
            case PT_M_GLASS:
            case PT_SID_MOUSE:
               break;
            default:
               goto CAT_CHASING;
         }
      }

      /* calculate the midpoint of the observed part */
      pptr_mid_x = pptr->scrn_loc.x + pptr->offset.x + (pptr->size.x >> 1);

      /* check if the object can be seen from the right */
      if (check_right && (cat_mid_x < pptr_mid_x))
      {
         return_val = cat_query_switch(cat, pptr);

         /* check if the object is opaque. If so then remember it. */
         if (is_opaque(cat,pptr,CAT_Y_THRESHOLD))
            check_right = 0;
      }

      /* check if the object can be seen from the left */
      if (check_left && (cat_mid_x > pptr_mid_x))
      {
         return_val = cat_query_switch(cat, pptr);

         /* check if the object is opaque. If so then remember it. */
         if (is_opaque(cat,pptr,CAT_Y_THRESHOLD))
            check_left = 0;
      }

      if (return_val != -1)
      {
         /* set the toon link; */
         cat->toon_link = pptr;
      
        /* adjust the orientation of the cat to face the target part */
         /* NOTE: flip is a variable which contains the original orientation */
         /* of the cat */
         if (!flip)
         {
            if (pptr->scrn_loc.x < cat->scrn_loc.x)
               cat_flip(cat, F2_FLIP_H_DRAW);
         }
         else
         {
            if (pptr->scrn_loc.x > cat->scrn_loc.x)
               cat_flip(cat, F2_FLIP_H_DRAW);
         }

         /* return the value of the index of the interaction closest to the cat */
         return((cat->sub_state = return_val));
      }
      else
CAT_CHASING:
         pptr = pptr->qptr;
   }

   /* check if the cat still has a valid link */
   if (!chasing)
   {
      /* check if the cat still has a toon link but can not decide what to do */
      if (  (return_val == -1)
         && ((pptr = cat->toon_link) != 0)
         && !(pptr->flags2 & F2_INACTIVE))
      {
         /* check if the link can still be seen. */
         /* NOTE: the full on check is not needed because the link was  */
         /* previously established. */
         if ((pptr->scrn_loc.y < cat->scrn_loc.y + cat->base_size.y) &&
            (pptr->scrn_loc.y + pptr->base_size.y > cat->scrn_loc.y))
            return(return_val);
         else
         {
            /* to get to this point the link can not be seen so cut it. */
            cat->toon_link = 0;
         
            /* set the sub state explicitly. This will be changed if a  */
            /* more interesting case is found below. */
            switch (cat->toon_state)
            {
               case CAT_RUN_INDEX:
               case CAT_RUNAW_INDEX:
                  return(cat->sub_state = CAT_STOP_INDEX);
               default:
                  return(cat->sub_state = CAT_ROOT_INDEX);
            }
         }
      }
      else
         cat->toon_link = 0;
   }

   return(return_val);
}



/* * * * *
*
*  SHORT cat_query_switch(PART *cat, PART *pptr);
*
*  This function performs the generic switch on the pptr.
*
* * * * */
SHORT cat_query_switch(PART *cat, PART *pptr)
{
   short cat_x,cat_y,cat_w,cat_h;
   short x,y,w,h;
   short return_val;

   switch (pptr->type)
   {
      case PT_SID_MOUSE:
         switch (pptr->toon_state)
         {
            /* check if the mouse is in an innocuous sequence */
            case SID_TUNNEL_INDEX:
            case SID_CUT_INDEX:
            case SID_BUTT_INDEX:
            case SID_CLIMB_INDEX:
            case SID_LUNCH_INDEX:
            case SID_PIANO_INDEX:
            case SID_BOMB_INDEX:
            case SID_DRAGON_INDEX:
            case SID_HDRYR_INDEX:
            case SID_HAIR_INDEX:
            case SID_HEADLESS_INDEX:
            case SID_VAC_INDEX:
            case SID_VAC2_INDEX:
            case SID_VAC3_INDEX:
            case SID_PENCIL1_INDEX:
            case SID_PENCIL2_INDEX:
            case SID_PENCIL3_INDEX:
            case SID_PENCIL4_INDEX:
            case SID_BANANA_INDEX:
            case SID_CHEESE_INDEX:
               return(-1);

            /* check if the mouse is in a sequence which indicates that it  */
            /* sees the cat */
            case SID_BRONX_INDEX:
            case SID_GIGGLE_INDEX:
               /* check to see that the cat stays in a certain state for  */
               /* at least a little while. */
               /* NOTE: This check assumes that the work_var is being  */
               /* incremented in the pertinent functions. */
               if (pptr->work_var > CAT_RUN_DELAY)
               {
                  /* This checks the orientation of the mouse to the cat. */
                  /* Are they facing each other? */
                  if (  ((pptr->qdist.x < 0)
                     && (pptr->flags2 & F2_FLIP_H_DRAW))
                     || ((pptr->qdist.x > 0)
                     && !(pptr->flags2 & F2_FLIP_H_DRAW))) 
                  {
                     /* check if the mouse is close enough to pounce on */
                     if (abs(pptr->qdist.x) < CAT_POUNCE_DIST)
                        return(CAT_POUNCE_INDEX);

                     /* check if the cat should spin out or run */
                     if (cat->toon_state != CAT_RUN_INDEX)
                        return(CAT_SPIN_INDEX);
                     else
                        return(CAT_RUN_INDEX);
                  }
                  else
                  {
                     cat_flip(cat, F2_FLIP_H_DRAW);
                     return(CAT_SPIN_INDEX);
                  }
               }
               break;

            /* check if the mouse is in a sequence which indicates that it is  */
            /* in motion */
/*            case SID_WALK_INDEX: */
            case SID_RUN_INDEX:
            case SID_SLIDE1_INDEX:
            case SID_SLIDE2_INDEX:
            case SID_SLIDE3_INDEX:
            case SID_SLIDE4_INDEX:
            case SID_PEEL_INDEX:
               /* This checks the orientation of the mouse to the cat. */
               /* Are they facing each other? */
               if (  ((pptr->qdist.x < 0)
                  && !(pptr->flags2 & F2_FLIP_H_DRAW))
                  || ((pptr->qdist.x > 0)
                  && (pptr->flags2 & F2_FLIP_H_DRAW))) 
               {
                  /* check if the mouse is close enough to pounce on */
                  if (abs(pptr->qdist.x) < CAT_POUNCE_RUN_DIST)
                     return(CAT_POUNCE_INDEX);

                  /* check if the cat should spin out or run */
                  if (cat->toon_state != CAT_RUN_INDEX)
                     return(CAT_SPIN_INDEX);
                  else
                     return(CAT_RUN_INDEX);
               }
               break;

            /* check if the mouse is in a sequence which indicates that it is  */
            /* or about to be in motion */
            case SID_HIT_FLOOR_INDEX:
            case SID_HIT_CEILING_INDEX:
            case SID_HIT_LEFT_WALL_INDEX:
            case SID_HIT_RIGHT_WALL_INDEX:
            case SID_STOP_INDEX:
            case SID_TAKE_INDEX:
               /* check if the mouse is close enough to pounce on */
               if (abs(pptr->qdist.x) < CAT_POUNCE_DIST)
                  return(CAT_POUNCE_INDEX);
               break;
         }

         /* check to see that the cat stays in a certain state for  */
         /* at least a little while. */
         /* NOTE: This check assumes that the work_var is being  */
         /* incremented in the pertinent functions. */
         /* NOTE: This assumption here is not very good. */
         if (pptr->work_var > CAT_RUN_DELAY)
         {
            /* check if the mouse is close enough to pounce on */
            if (abs(pptr->qdist.x) < CAT_POUNCE_DIST)
               return(CAT_POUNCE_INDEX);
         }
         break;
      case PT_LADDER:
         /* check to see if the cat just recently got off the a ladder */
         if (  ((cat->work_var1 >> CAT_SHIFT) == CAT_CLIMB_INDEX)
            || (cat->toon_state == CAT_CLIMB_INDEX))
            return(-1);

         x = pptr->scrn_loc.x;
         y = pptr->scrn_loc.y;
         w = pptr->size.x;
         h = pptr->size.y;
         cat_x = cat->scrn_loc.x;
         cat_y = cat->scrn_loc.y;
         cat_w = cat->base_size.x;
         cat_h = cat->base_size.y;

         /* check if the cat is out of range of the ladder */
         if (  (cat_x + (cat_w>>1) < x)
            || (x + w < cat_x + (cat_w>>1))
            || (cat_y + cat_h < y)
            || (y + h < cat_y))
             return(-1);
         else
             return(CAT_CLIMB_INDEX);
      case PT_BOMB:
         /* check if the bomb is about to explode near the cat */
         if (pptr->state && (abs(pptr->qdist.x) < 60))
         {
            cat_flip(cat, F2_FLIP_H_DRAW);

            /* check if the cat should spin out or run from the bomb */
            if (cat->toon_state != CAT_RUNAW_INDEX)
               return(CAT_SPINAW_INDEX);
            else
               return(CAT_RUNAW_INDEX);
         }
         return(-1);
      case PT_DRAGON:
         /* Is the dragon about to blow near the cat and check the orientation  */
         /* of the dragon to the cat. Is it facing him. */
         if (pptr->state && (pptr->state < 5) && (abs(pptr->qdist.x) < 60) &&
            (((pptr->scrn_loc.x < cat->scrn_loc.x) &&
            (pptr->flags2 & F2_FLIP_H_DRAW)) ||
            ((pptr->scrn_loc.x > cat->scrn_loc.x) &&
            !(pptr->flags2 & F2_FLIP_H_DRAW))))
         {
            cat_flip(cat, F2_FLIP_H_DRAW);
            if (cat->toon_state != CAT_RUNAW_INDEX)
               return(CAT_SPINAW_INDEX);
            else
               return(CAT_RUNAW_INDEX);
         }
         return(-1);
      case PT_HANDGUN:
         /* Is the gun about to shoot near the cat and check the orientation  */
         /* of the gun to the cat. Is it facing him. */
         if (pptr->state &&
            (((pptr->scrn_loc.x < cat->scrn_loc.x) &&
            !(pptr->flags2 & F2_FLIP_H_DRAW)) ||
            ((pptr->scrn_loc.x > cat->scrn_loc.x) &&
            (pptr->flags2 & F2_FLIP_H_DRAW))))
         {
            cat_flip(cat, F2_FLIP_H_DRAW);
            if (cat->toon_state != CAT_RUNAW_INDEX)
               return(CAT_SPINAW_INDEX);
            else
               return(CAT_RUNAW_INDEX);
         }
         return(-1);
      case PT_FISH:
      case PT_GUM:
         return(CAT_WALK_INDEX);
      case PT_BANANA:
         if (pptr->state != BANANA_PEEL)
            return(CAT_WALK_INDEX);
         else
            return(-1);
      case PT_M_GLASS:
         return(magnify_check_cat(pptr, cat));
      case PT_SCISSORS:
         if (!pptr->state &&
            (((cat->scrn_loc.x > pptr->scrn_loc.x) &&
            !(pptr->flags2 & F2_FLIP_H_DRAW)) ||
            ((cat->scrn_loc.x<pptr->scrn_loc.x+pptr->size.x) &&
            (pptr->flags2 & F2_FLIP_H_DRAW))))
         {
            return(CAT_WALK_INDEX);
         }
         return(-1);
      case PT_TUNNEL:
         if ((cat->work_var1 >> CAT_SHIFT) != CAT_TUNNEL_INDEX)
         {
            return_val = -1;

            /* check the vertical placement of the cat */
            if ((cat->scrn_loc.y > pptr->scrn_loc.y + 0) &&
               (cat->scrn_loc.y < pptr->scrn_loc.y + 20))
            {
               /* check the orientation of the cat */
               if (cat->flags2 & F2_FLIP_H_DRAW)
               {
                  /* check the horizontal placement of the cat */
                  if ((cat->scrn_loc.x > pptr->scrn_loc.x + 20) &&
                     (cat->scrn_loc.x < pptr->scrn_loc.x + 40))
                     return_val = CAT_TUNNEL_INDEX;
               }
               else
               {
                  /* check the horizontal placement of the cat */
                  if ((cat->scrn_loc.x > pptr->scrn_loc.x - 30) &&
                     (cat->scrn_loc.x < pptr->scrn_loc.x))
                     return_val = CAT_TUNNEL_INDEX;
               }
         
               /* check if the cat should go into the tunnel */
               /* NOTE: I am explicitly overwriting the memory field */
               /* of the cat. It may have some wierd repercussions if the  */
               /* sub_state fails to change the toon_state */
               if (return_val > 0)
                  cat->memory = cat->toon_state;
            }

            return(return_val);
         }
         break;
      case PT_YARNBALL:
         /* check if the yarn ball is far from the cat */
         if (abs((cat->scrn_loc.x + (cat->base_size.x>>1)) -
            (pptr->scrn_loc.x + (pptr->base_size.x>>1))) > CAT_POUNCE_DIST)
            return(CAT_WALK_INDEX);

         /* check if the cat should pounce on the yarn ball */
         if (cat->toon_state == CAT_SCRATCH_INDEX)
            return(CAT_POUNCE_INDEX);

         return(CAT_SCRATCH_INDEX);
      default:
         return(-1);
   }
   return(-1);
}



/* * * * *
*
*  void cat_root(PART *cat);
*
* * * * */
void cat_root(PART *cat)
{
   #define CAT_AWAKE_TIME     60

   if (cat_observation(cat) < 0)
   {
      if (cat->speed.y >= CAT_FALLING)
         cat->sub_state = CAT_FLAIL_INDEX;
      else
      {
         cat->work_var++;
         if (cat->work_var >= CAT_AWAKE_TIME)
            cat->sub_state = CAT_SLEEP_INDEX;
      }
   }
   al_cat_reinit(cat);
}


/* * * * *
*
*  void cat_sleep(PART *cat);
*
* * * * */
void cat_sleep(PART *cat)
{
   static const char far state_array[] =
   {
      0,2,2,2,0,1,1,1
   };
   #define SLEEP_NUM_STATES (sizeof(state_array)/sizeof(char))
   #define SLEEP_RATE   3

   if (!(++cat->work_var % SLEEP_RATE))
   {
      if (cat->speed.y >= CAT_FALLING)
         cat->sub_state = CAT_FLAIL_INDEX;

      cat->state = CAT_SLEEP_SEQ + state_array[cat->work_var / SLEEP_RATE];
      if (cat->work_var >= SLEEP_NUM_STATES * SLEEP_RATE)
      {
         cat->work_var = 0;
         cat->state = CAT_SLEEP_SEQ;
         jtp_sx_play(SX_CAT_SNORING,0,0);
      }
      al_cat_reinit(cat);
   }
}



/* * * * *
*
*  void cat_bomb(PART *cat);
*
* * * * */
void cat_bomb(PART *cat)
{
   static const char far state_array[] =
   {
      0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
      2,2,3,3,3,3,4,4,5,5,6,6,7,7,8,8,9,9,8,8,9,9,8,8,8,8,8,8,8,8
   };
   #define NUM_STATES (sizeof(state_array)/sizeof(char))

   if (++cat->work_var < NUM_STATES)
   {
      cat->state = state_array[cat->work_var] + CAT_BOMB_SEQ;
      al_cat_reinit(cat);
      if ((cat->state == 2+CAT_BOMB_SEQ) &&
         (cat->old_state == 0+CAT_BOMB_SEQ))
         jtp_sx_play(SX_CAT_BOMB,2,0);
   }
   else
      kill_character(cat);
}


/* * * * *
*
*  void cat_shake(PART *cat);
*
* * * * */
void cat_shake(PART *cat)
{
   static const char far state_array[] =
   {
      0,1,2,3,2,1,0,1,2,3
   };
   #define SHAKE_NUM_STATES      (sizeof(state_array)/sizeof(char)) 

   /* move the part to the static list. */
   if (!cat->work_var)
      jtp_sx_play(SX_CAT_SHAKE,0,0);

   if (++cat->work_var < SHAKE_NUM_STATES)
   {
      cat->state = state_array[cat->work_var] + CAT_SHAKE_SEQ;
      al_cat_reinit(cat);
   }
   else
      cat->sub_state = CAT_ROOT_INDEX;
}


/* * * * *
*
*  void cat_crack(PART *cat);
*
* * * * */
void cat_crack(PART *cat)
{
   static const char far state_array[] =
   {
      0,0,0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,4,4,4,4,4,4,
      5,5,5,6,6,6,7,7,7,8,8,8,9,9,9
   };
   #define CRACK_NUM_STATES   (sizeof(state_array)/sizeof(char)) 

   /* move the part to the static list. */
   if (!cat->work_var)
      jtp_sx_play(SX_CAT_CRACK,2,0);

   if (++cat->work_var < CRACK_NUM_STATES)
   {
      cat->state = state_array[cat->work_var] + CAT_CRACK_SEQ;
      al_cat_reinit(cat);
      if ((cat->state == 5+CAT_CRACK_SEQ) &&
         (cat->old_state == 4+CAT_CRACK_SEQ))
         jtp_sx_play(SX_CAT_CRUMBLE,2,0);
   }
   else
      kill_character(cat);
}


/* * * * *
*
*  void cat_walk(PART *cat);
*
* * * * */
void cat_walk(PART *cat)
{
   #define WALK_RATE        1
   #define CAT_WALK_TIME    10

   /* offset coordinates for a sequence of cells for the cat. */
   static const char far cat_walk_os[CAT_WALK_NUM_STATES] =
   {
      5,5,5,5,3,2,3,4,5,1,5
   };

   short sign;
   
   /* reset the cats speed */
   cat->speed.x = 0;

   if (!(++cat->work_var % WALK_RATE))
   {
      /* animate the walk */
      cat->state++;
      if (cat->state >= CAT_WALK_SEQ + CAT_WALK_NUM_STATES)
      {
         cat->state = CAT_WALK_SEQ;
         jtp_sx_play(SX_CAT_WALK,0,0);
      }

      /* move the cat the desired distance */
      if (cat->flags2 & F2_FLIP_H_DRAW)
         sign = -1;
      else
         sign = 1;

      cat->speed.x =
         sign * short_to_pix(cat_walk_os[cat->state - CAT_WALK_SEQ]);

      al_cat_reinit(cat);
      
      /* check if the cat is falling */
      if (cat->speed.y > CAT_FALLING)
         cat->sub_state = CAT_FLAIL_INDEX;

      /* observe surroundings. */
      if ((cat_observation(cat) == -1) &&
         (cat->work_var > CAT_WALK_TIME * WALK_RATE) && !cat->toon_link)
      {
         cat->sub_state = CAT_ROOT_INDEX;
         cat->speed.x = 0;
      }
   }
}


/* * * * *
*
*  void cat_run(PART *cat);
*
* * * * */
void cat_run(PART *cat)
{
   #define CAT_RUN_TIME    10
   
   /* offset coordinates for a sequence of cells for the cat. */
   static const char far cat_run_os[CAT_RUN_NUM_STATES] = 
   {
      15,12,9,14
   };

   short sign;

   /* reset the speed */
   cat->speed.x = 0;

   /* animate the run */
   cat->state++;
   if (cat->state >= CAT_RUN_SEQ + CAT_RUN_NUM_STATES)
   {
      cat->state = CAT_RUN_SEQ;
      jtp_sx_play(SX_CAT_RUN,0,0);
   }

   if (cat->flags2 & F2_FLIP_H_DRAW)
      sign = -1;
   else
      sign = 1;

   cat->speed.x =
      sign * short_to_pix(cat_run_os[cat->state - CAT_RUN_SEQ]);
   al_cat_reinit(cat);
   
   /* check if the cat is falling */
   if (cat->speed.y > CAT_FALLING)
      cat->sub_state = CAT_FLAIL_INDEX;

   /* check surroundings */
   cat->work_var++;
   if ((cat_observation(cat) == -1) &&
      (cat->work_var > CAT_RUN_TIME) && !cat->toon_link)
   {
      cat->sub_state = CAT_STOP_INDEX;
      cat->speed.x = 0;
   }
}


/* * * * *
*
*  void cat_hair(PART *cat);
*
* * * * */
void cat_hair(PART *cat)
{
   #define HAIRBALL_RATE      2
   #define HAIRBALL_START_X   40
   #define HAIRBALL_FSTART_X  -25
   #define HAIRBALL_START_Y   2

   static const char far state_array[] =
   {
      0,0,
      1,1,2,2,3,3,                              
      1,1,2,2,3,3,                              
      1,1,2,2,3,3,                              
      0,0,                                  
      4,4,4,4,4,4,5,6,7,8,9,              
      4,4,4,4,4,4,5,6,7,8,9,              
      4,4,4,4,4,4,5,6,7,8,9,              
      10,10,10,10,10,10,10,10,            
      11,11,11,11,11,11,                  
      12,12,12,12,                        
      10,10,10,10,10,10,10,10,10,10       
   };
   #define HAIR_NUM_STATES    (sizeof(state_array)/sizeof(char))    

   if (++cat->work_var < HAIR_NUM_STATES * HAIRBALL_RATE)
   {
      if (!(cat->work_var % HAIRBALL_RATE))
      {
         /* animate the cat in horking a hairball */
         cat->state = state_array[cat->work_var / HAIRBALL_RATE] +
            CAT_HAIR_SEQ;
         al_cat_reinit(cat);

         /* play sound effects */
         if (cat->state == 1+CAT_HAIR_SEQ)
            jtp_sx_play(SX_CAT_LICK_TAIL,4,0);
         if (cat->state == 7+CAT_HAIR_SEQ)
            jtp_sx_play(SX_CAT_GAG,4,0);
         if ((cat->state == 12+CAT_HAIR_SEQ) &&
            (cat->old_state == 11+CAT_HAIR_SEQ))
            jtp_sx_play(SX_CAT_HAIR,4,0);
      }
   }
   else
      cat->sub_state = CAT_ROOT_INDEX;

   /* create the hair ball. */
   if ((cat->state == 10+CAT_HAIR_SEQ) &&
      (cat->old_state == 12+CAT_HAIR_SEQ))
   {
      if (cat->flags2 & F2_FLIP_H_DRAW)
         create_part(PT_HAIR_BALL,
            cat->scrn_loc.x+HAIRBALL_FSTART_X,
            cat->scrn_loc.y+HAIRBALL_START_Y,
            cat->scrn_loc.x+HAIRBALL_FSTART_X,
            cat->scrn_loc.y+HAIRBALL_START_Y,
            -HAIR_SPEED,-FOUR_PIX,0,F2_FLIP_H_DRAW);
      else
         create_part(PT_HAIR_BALL,
            cat->scrn_loc.x+HAIRBALL_START_X,
            cat->scrn_loc.y+HAIRBALL_START_Y,
            cat->scrn_loc.x+HAIRBALL_START_X,
            cat->scrn_loc.y+HAIRBALL_START_Y,
            HAIR_SPEED,-FOUR_PIX,0,0);
   }
}


                                 
/* * * * *
*
*  void cat_birds(PART *cat);
*
* * * * */
void cat_birds(PART *cat)
{
   static const char far state_array[] =
   {
      0,1,2,3,4,5,6,7,8,9,10,0,1,2,3,4,5,6,7,8,9,10
   };
   #define BIRDS_NUM_STATES   (sizeof(state_array)/sizeof(char))  

   /* check for sound effects */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_BIRDS_BONK,0,0);
      jtp_sx_play(SX_CAT_BIRDS,0,0);
   }

   if (++cat->work_var < BIRDS_NUM_STATES)
   {
      cat->state = state_array[cat->work_var] + CAT_BIRDS_SEQ;
      al_cat_reinit(cat);
   }
   else
      cat->sub_state = CAT_ROOT_INDEX;
}


/* * * * *
*
*  void cat_flail(PART *cat);
*
* * * * */
void cat_flail(PART *cat)
{
   /* check for sound effects */
   if (!cat->work_var)
      jtp_sx_play(SX_CAT_FLAIL,1,0);

   /* this is only done for consistency */
   cat->work_var++;

   if (cat->state < CAT_FLAIL_SEQ + CAT_FLAIL_NUM_STATES - 1)
      cat->state++;
   else
      cat->state = CAT_FLAIL_SEQ;

   al_cat_reinit(cat);
}



/* * * * *
*
*  void cat_shot(PART *cat);
*
* * * * */
void cat_shot(PART *cat)
{
   #define AL_CAT_START_X     0
   #define AL_CAT_START_Y     0
   #define AL_CAT_FSTART_X    0
   #define AL_CAT_FSTART_Y    0

   signed char new_state;
   PART *angel_cat;
   short sign;
   
   static const char far state_array[] =
   {
      0,0,0,0,0,0,0,0,0,
      1,1,1,1,1,1,1,1,1,1,1,
      2,3,4,5,6,7,8,9,10,11,12,
      13,13,13,13,13,13,13,13,13,13,13,
      14,14,14,14,
      15,16,17,18,19,20,21,22,23,24,25,26,26,27,28,29,
      30,30,30,30,30,30,30
   };
   #define SHOT_NUM_STATES   (sizeof(state_array)/sizeof(CHAR))   

   /* offset coordinates */
   static const char far cat_shot_os[][3] =
   {
      {0,0,1},{0,0,2},
      {0,0,3},{4,-4,3},{0,4,3},{0,-4,3},{4,4,3},{-4,0,3},{-4,-4,3},{0,4,3},
      {4,-4,3},{0,4,3},{-4,0,3},
      {0,0,4},{0,0,5},{-7,0,6},{-5,0,7},{-3,0,8},{0,0,8},{3,0,7},
      {0,0,7},{0,0,6},{0,0,7},{0,0,8},{0,0,7},{0,0,7},{0,0,7},
      {0,0,9},{0,0,10},{0,0,11},{0,0,12}
   };
   #define SHOT_NUM_OFFSETS  (sizeof(cat_shot_os)/(sizeof(CHAR) * 3))          

   /* reset whatever needs to be */
   if (!cat->work_var)
   {
      cat->toon_link = 0;
      cat->speed.y = 0;
      cat->memory = -1;
   }

   /* prevent the cat from moving left or right */
   cat->speed.x = 0;

   ++cat->work_var;
   if (cat->work_var < SHOT_NUM_STATES)
   {
      new_state = state_array[cat->work_var];

      /* check for sound effects */
      if (new_state == 2)
         jtp_sx_play(SX_CAT_SHOT_HIT,4,0);
      if (new_state == 18)
         jtp_sx_play(SX_CAT_SHOT,4,0);
      if (new_state == 27)
         jtp_sx_play(SX_CAT_SHOT_LILI,4,0);

      if (new_state != cat->memory)
      {
         /* set up for the correct offset */
         if (cat->flags2 & F2_FLIP_H_DRAW)
            sign = -1;
         else
            sign = 1;

         cat->state = cat_shot_os[new_state][2] - 1 + CAT_SHOT_SEQ;
         cat->speed.x += sign * short_to_pix(cat_shot_os[new_state][0]);
         cat->speed.y += short_to_pix(cat_shot_os[new_state][1]);
         cat->memory = new_state;
         al_cat_reinit(cat);
      }
   }
   else
   {
      /* create only one angel */
      if (cat->work_var == SHOT_NUM_STATES)
      {
         /* create angel cat */
         if (cat->flags2 & F2_FLIP_H_DRAW)
            angel_cat = create_part(PT_AL_CAT,
               cat->scrn_loc.x+AL_CAT_FSTART_X,
               cat->scrn_loc.y+AL_CAT_FSTART_Y,
               cat->scrn_loc.x+AL_CAT_FSTART_X,
               cat->scrn_loc.y+AL_CAT_FSTART_Y,
               0,0,F1_STATIC,F2_FLIP_H_DRAW);
         else
            angel_cat = create_part(PT_AL_CAT,
               cat->scrn_loc.x+AL_CAT_START_X,
               cat->scrn_loc.y+AL_CAT_START_Y,
               cat->scrn_loc.x+AL_CAT_START_X,
               cat->scrn_loc.y+AL_CAT_START_Y,
               0,0,F1_STATIC,0);
      
         angel_cat->toon_state = CAT_ANGEL_INDEX;
         angel_cat->state = CAT_ANGEL_SEQ;
         angel_cat->work_var = 0;
         angel_cat->border = 0;
         cat->toon_link = angel_cat;
         al_cat_reinit(angel_cat);
      }
   }
}


/* * * * *
*
*  void cat_angel(PART *cat);
*
* * * * */
void cat_angel(PART *cat)
{
   #define ANGEL_RATE    3

   /* offset coordinates */
   static TIM_SCVEC_C cat_angel_os[CAT_ANGEL_NUM_STATES] =
   {
      {-6,-14},{4,-14},{4,-15}
   };
   
   if (!(++cat->work_var % ANGEL_RATE))
   {
      cat->state++;
      
      if (cat->state >= CAT_ANGEL_SEQ + CAT_ANGEL_NUM_STATES) 
      {
         cat->state = CAT_ANGEL_SEQ;
         if (cat->scrn_loc.y > tedge - 100)
            jtp_sx_play(SX_CAT_ANGEL,3,0);
      }

      cat->loc.x=cat->scrn_loc.x+=cat_angel_os[cat->state-CAT_ANGEL_SEQ].x;
      cat->loc.y=cat->scrn_loc.y+=cat_angel_os[cat->state-CAT_ANGEL_SEQ].y;
      cat->loc.x <<= SCALE_SHIFT;
      cat->loc.y <<= SCALE_SHIFT;
      al_cat_reinit(cat);
   }
}


/* * * * *
*
*  void cat_spin(PART *cat);
*
* * * * */
void cat_spin(PART *cat)
{
   #define SPIN_TIME    18

   /* check for sound effects */
   if (!cat->work_var)
      cat_spin_sx();

   if (cat->state < CAT_SPIN_SEQ + CAT_SPIN_NUM_STATES - 1)
      cat->state++;
   else
      cat->state = CAT_SPIN_SEQ;

   /* check for spin time */
   cat->work_var++;
   if (cat->work_var > SPIN_TIME)
      cat->sub_state = CAT_RUN_INDEX;

   /* check if the cat has begun to fall */
   if (cat->speed.y >= CAT_FALLING)
      cat->sub_state = CAT_FLAIL_INDEX;

   al_cat_reinit(cat);
}


/* * * * *
*
*  void cat_skid(PART *cat);
*
* * * * */
void cat_skid(PART *cat)
{
   #define SKID_TIME    9

   /* check for sound effects */
   if (!cat->work_var)
      jtp_sx_play(SX_CAT_SKID,1,0);

   if (cat->state < CAT_SKID_SEQ + CAT_SKID_NUM_STATES - 1)
      cat->state++;
   else
      cat->state = CAT_SKID_SEQ;

   cat->work_var++;
   if (cat->work_var > SKID_TIME)
      cat->sub_state = CAT_ROOT_INDEX;

   if (cat->speed.y >= CAT_FALLING)
      cat->sub_state = CAT_FLAIL_INDEX;

   al_cat_reinit(cat);
}


/* * * * *
*
*  void cat_ate(PART *cat);
*
* * * * */
void cat_ate(PART *cat)
{
   static const char far state_array[] =
   {
      1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,15,15,15,15,15,16,17,18,19,20,21,22,
      23,23,23,23,24,24,24,24,24,24,24,24,25,24,26,24,25,24,26,24,25,24,26,
      24,24,27,28,27,28,27,28,27,28,29,30,31,32,33,34,35,36,37,38,38,38,38,
      39,38,39,38,39,38,39,38,39,38,39,38,38,38,38,38,40,40,40,41,41,42,42,43,
      44,45,46,42,42,47,47,47,47,47
   };
   #define ATE_NUM_STATES     (sizeof(state_array)/sizeof(CHAR))   
   #define ATE_RATE           2

   short index;

   /* if first time into the sequence, kill the velocity */
   if (!cat->work_var)
      cat->speed.x = cat->speed.y = 0;

   if (!(++cat->work_var % ATE_RATE))   
   {
      index = cat->work_var / ATE_RATE;

      if (index < ATE_NUM_STATES)
      {
         cat->state = state_array[index] + CAT_ATE_SEQ - 1;
         al_cat_reinit(cat);

         if (cat->state < 14 + CAT_ATE_SEQ)
            cat_fight_sx();
         if (  (cat->state == 24 + CAT_ATE_SEQ)
            && (cat->old_state == 23 + CAT_ATE_SEQ))
            jtp_sx_play(SX_CAT_ATE_SHAKE,3,0);
         if (  (cat->state ==  26 + CAT_ATE_SEQ)
            && (cat->old_state ==  23 + CAT_ATE_SEQ))
            jtp_sx_play(SX_CAT_ATE_CRUMPLE,3,0);
         if (  (cat->state ==  29 + CAT_ATE_SEQ)
            && (cat->old_state == 28 + CAT_ATE_SEQ))
            jtp_sx_play(SX_CAT_ATE_THROW,3,0);
         if (  (cat->state == 36 + CAT_ATE_SEQ)
            && (cat->old_state == 35 + CAT_ATE_SEQ))
            jtp_sx_play(SX_CAT_ATE_GULP,3,0);
         if (  (cat->state == 38 + CAT_ATE_SEQ)
            && (cat->old_state == 37 + CAT_ATE_SEQ))
            jtp_sx_play(SX_CAT_ATE_CHEW,3,0);
         if (  (cat->state == 39 + CAT_ATE_SEQ)
            && (cat->old_state == 37 + CAT_ATE_SEQ))
            jtp_sx_play(SX_CAT_ATE_GULP,3,0);
         if (cat->state == 42 + CAT_ATE_SEQ)
            jtp_sx_play(SX_CAT_ATE_SLURP,3,0);
         if (cat->state == 46 + CAT_ATE_SEQ)
            jtp_sx_play(SX_CAT_ATE_BURP,3,0);
      }
      else
      {
         /* override preempt */
         cat->sub_state = cat->toon_state = CAT_ROOT_INDEX;
         cat->state = CAT_ROOT_SEQ;
         cat->work_var = 0;
      }
   }
}


/* * * * *
*
*  void cat_runaw(PART *cat);
*
* * * * */
void cat_runaw(PART *cat)
{
   #define CAT_RUNAW_TIME    30

   /* offset coordinates */
   static const char far cat_runaw_os[CAT_RUNAW_NUM_STATES] =
   {
      15,12,9,14
   };

   short sign;
   
   cat->speed.x = 0;
   
   /* animate the cat running away */
   cat->state++;
   if (cat->state >= CAT_RUNAW_SEQ + CAT_RUNAW_NUM_STATES)
   {
      cat->state = CAT_RUNAW_SEQ;
      jtp_sx_play(SX_CAT_RUNAW,1,0);
   }

   if (cat->flags2 & F2_FLIP_H_DRAW)
      sign = -1;
   else
      sign = 1;

   cat->speed.x = sign * short_to_pix(cat_runaw_os[cat->state-CAT_RUNAW_SEQ]);

   al_cat_reinit(cat);

   /* check if the cat is falling */
   if (cat->speed.y >= CAT_FALLING)
      cat->sub_state = CAT_FLAIL_INDEX;

   /* observe the sourroundings */
   cat->work_var++;
   if ((cat->work_var > CAT_RUNAW_TIME) &&
      (cat_observation(cat) == -1))
   {
      cat->sub_state = CAT_STOP_INDEX;
      cat->speed.x = 0;
   }
}


/* * * * *
*
*  void cat_spinaw(PART *cat);
*
* * * * */
void cat_spinaw(PART *cat)
{
   #define SPINAW_TIME    20

   /* check for sound effect */
   if (!cat->work_var)
      jtp_sx_play(SX_CAT_SPINAW,1,0);

   /* animate spin away */
   if (cat->state < CAT_SPINAW_SEQ + CAT_SPINAW_NUM_STATES - 1)
      cat->state++;
   else
      cat->state = CAT_SPINAW_SEQ;

   cat->work_var++;
   if (cat->work_var > SPINAW_TIME)
      cat->sub_state = CAT_RUNAW_INDEX;

   if (cat->speed.y >= CAT_FALLING)
      cat->sub_state = CAT_FLAIL_INDEX;

   al_cat_reinit(cat);
}


/* * * * *
*
*  void cat_take(PART *cat);
*
* * * * */
void cat_take(PART *cat)
{
   #define TAKE_NUM_STATES     33   

   short index, sign;

   /* offset coordinates */
   signed char cat_take_os[TAKE_NUM_STATES][3] =
   {
      {-32,-12,1},{0,0,1},{0,0,1},{0,0,1},{0,0,2},{0,-2,3},{0,-4,4},
      {-2,-2,4},{2,2,4},{-1,1,4},{-1,2,4},{2,2,4},{-2,-2,4},{-2,-2,4},
      {2,2,4},{-1,1,4},{1,-1,4},{2,2,4},{-2,-2,4},{-2,-2,4},{2,2,4},
      {-1,2,4},{1,-1,4},{2,2,4},{-2,-2,4},{0,4,3},{0,2,2,},{0,0,1},
      {0,0,1},{0,0,1},{0,0,1},{0,0,1},{0,0,1}
   };

   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_TAKE,2,0);
      cat->speed.x = cat->speed.y = 0;
      cat->work_var1 = -1;
   }

   if (++cat->work_var < TAKE_NUM_STATES - 1)
   {
      index = cat->work_var;

      if (cat->flags2 & F2_FLIP_H_DRAW)
         sign = -1;
      else
         sign = 1;

      cat->state = cat_take_os[index][2] + CAT_TAKE_SEQ - 1;
      cat->speed.x = sign * short_to_pix(cat_take_os[index][0]);
      cat->speed.y = sign * short_to_pix(cat_take_os[index][1]);
      al_cat_reinit(cat);
   }
   else
   {
      cat->sub_state = CAT_SPINAW_INDEX;
      cat_flip(cat,F2_FLIP_H_DRAW);
   }
}

/* * * * *
*
*  void cat_climb(PART *cat);
*
* * * * */
void cat_climb(PART *cat)
{
   #define CLIMB_RATE            2
   #define CLIMB_REST1           15
   #define CLIMB_NUM_OFFSETS     4

   short index, exit_y, cat_y;
   PART *ladder;

   static signed const char far cat_climb_os[CLIMB_NUM_OFFSETS][2] =
   {
      {-3,0},{-9,1},{-1,2},{-10,1}
   };
   static signed const char far cat_fclimb_os[CLIMB_NUM_OFFSETS][2] =
   {
      {10,0},{1,1},{9,2},{3,1}
   };

   if (!(++cat->work_var % CLIMB_RATE))
   {
      if (cat->work_var == CLIMB_NUM_OFFSETS * CLIMB_RATE)
         cat->work_var = 0;

      /* animate the climbing of the ladder */
      index = cat->work_var / CLIMB_RATE;
      if (cat->memory & MEMORY_DOWN_BIT)
      {
         cat->state = cat_fclimb_os[index][1] + CAT_CLIMB_SEQ;
         cat->scrn_loc.y += cat_fclimb_os[index][0];
      }
      else
      {
         cat->state = cat_climb_os[index][1] + CAT_CLIMB_SEQ;
         cat->scrn_loc.y += cat_climb_os[index][0];
      }

      if (  (cat->state == CAT_CLIMB_SEQ)
         || (cat->state == 2 + CAT_CLIMB_SEQ))
         jtp_sx_play(SX_CAT_CLIMB,0,0);

      cat_y = cat->scrn_loc.y + (cat->size.y >> 1);
      ladder = cat->toon_link;   /* This assumes the pointer is ok */
      
      /* check for the end of the ladder */
      if (  (cat_y > ladder->scrn_loc.y + ladder->size.y)
         || (cat_y < ladder->scrn_loc.y))
      {
         /* reverse the direction of the cat and recalculate the exit location */
         cat->scrn_loc.y = cat->old_scrn_loc.y;
         cat->memory ^= MEMORY_DOWN_BIT;
         cat->memory &= MEMORY_EXIT_BLOCK ^ 0xffff;
         cat->memory |= ladder_exit(cat,ladder,
            cat->memory&MEMORY_DOWN_BIT,1) << EXIT_SCALE;

         /* verify that the cat has an exit block */
         if (!(cat->memory & MEMORY_DOWN_BIT) &&
            ((cat->memory & MEMORY_EXIT_BLOCK)>>EXIT_SCALE) == MEMORY_NO_EXIT)
            cat->memory &= 0xffff ^ MEMORY_EXIT_BLOCK; 
      }

      cat->loc.y = (long)cat->scrn_loc.y << SCALE_SHIFT;
      al_cat_reinit(cat);

      cat_y = (cat->scrn_loc.y >> BLOCK_SCALE);
      exit_y = ((cat->memory & MEMORY_EXIT_BLOCK) >> EXIT_SCALE) -
         (cat->size.y >> BLOCK_SCALE);

      /* check current location compared to the exit location. */
      if (  (cat_y == exit_y)
         || (cat_y == exit_y + 1))
      {
         /* exit climb sequence. */
         cat->toon_link = 0;

         /* orient the cat  */
         if (  ((cat->memory & MEMORY_ORIENT_LEFT_BIT)
            && (!(cat->flags2 & F2_FLIP_H_DRAW)))
            || (!(cat->memory & MEMORY_ORIENT_LEFT_BIT)
            && (cat->flags2 & F2_FLIP_H_DRAW)))
            cat_flip(cat, F2_FLIP_H_DRAW);

         /* reposition cat on the new floor. */
         cat->loc.y =
            cat->old_old_scrn_loc.y =
            cat->old_scrn_loc.y =
            cat->scrn_loc.y =
               (((cat->memory & MEMORY_EXIT_BLOCK) >> EXIT_SCALE)
               << BLOCK_SCALE) - cat->base_size.y + 5;

         cat->loc.x = cat->old_scrn_loc.x = cat->scrn_loc.x;
         cat->loc.y <<= SCALE_SHIFT;
         cat->loc.x <<= SCALE_SHIFT;
         cat->work_var1 = (CAT_CLIMB_INDEX << CAT_SHIFT) | CLIMB_REST1;
         cat->work_var = cat->speed.y = 0;
         character_from_static_to_move(cat);

         /* check if nothing interesting was seen */
         if (cat_observation(cat) == -1)
         {
            /* default to the previous state */
            if (cat->memory & MEMORY_RUN_BIT)
            {
               cat->sub_state = cat->toon_state = CAT_RUN_INDEX;
               cat->state = CAT_RUN_SEQ;
            }
            else
            {
               cat->sub_state = cat->toon_state = CAT_WALK_INDEX;
               cat->state = CAT_WALK_SEQ;
            }
         }
         else
         {
            /* This will fix the small ladder exit problem */
            if (cat->sub_state == CAT_SPIN_INDEX)
               cat->sub_state = CAT_RUN_INDEX;

            cat->toon_state = cat->sub_state;
            cat->state = abs(cat_tables[cat->sub_state].index2seq);
         }
      }
      else
      {
         /* check if the cat has past the intended exit */
         if (  ((cat->memory & MEMORY_DOWN_BIT)
            && (cat_y > exit_y))
            || (!(cat->memory & MEMORY_DOWN_BIT)
            && (cat_y < exit_y))) 
         {
            cat->memory ^= MEMORY_DOWN_BIT;
            cat->memory &= MEMORY_EXIT_BLOCK ^ 0xffff;
            cat->memory |= ladder_exit(cat,ladder,
               cat->memory&MEMORY_DOWN_BIT,1) << EXIT_SCALE;

            /* verify that the cat has an exit block */
            if (  !(cat->memory & MEMORY_DOWN_BIT)
               && (((cat->memory & MEMORY_EXIT_BLOCK) >> EXIT_SCALE)
               == MEMORY_NO_EXIT))
               cat->memory &= 0xffff ^ MEMORY_EXIT_BLOCK; 
         }
      }
   }
}

/* * * * *
*
*  void cat_cut(PART *cat);
*
*  This function assume that the specified cat is in the correct position.
*
* * * * */
void cat_cut(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1,2,2,2,2,2,2,3,3,3,4,4
   };
   #define CUT_NUM_STATES     (sizeof(state_array)/sizeof(char))

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      cat->speed.x = cat->speed.y = 0;
      character_from_move_to_static(cat);
   }

   if (++cat->work_var < CUT_NUM_STATES)
   {
      cat->state = state_array[cat->work_var] - 1 + CAT_CUT_SEQ;
      al_cat_reinit(cat);
      
      /* check if the scissors should be cut */
      if ((cat->state == 3 + CAT_CUT_SEQ) &&
         (cat->old_state == 2 + CAT_CUT_SEQ) &&
         cat->toon_link && (cat->toon_link->type == PT_SCISSORS))
         cat->toon_link->sub_state = 1;
   }
   else
   {
      cat->sub_state = CAT_ROOT_INDEX;
      character_from_static_to_move(cat);
      
      /* reposition cat to be on the ground near the scissors. */
      cat->loc.y = cat->scrn_loc.y =
         cat->toon_link->scrn_loc.y + cat->toon_link->size.y - 14;
      cat->loc.y <<= SCALE_SHIFT;
      al_cat_reinit(cat);
   }
}

/* * * * *
*
*  void cat_stop(PART *cat);
*
* * * * */
void cat_stop(PART *cat)
{
   static const char far state_array[] =
   {
      1,2,3,4,5,6
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define STOP_RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_STOP,1,0);

      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }
   
   if (!(++cat->work_var % STOP_RATE))
   {
      if (cat->work_var < NUM_STATES * STOP_RATE)
      {
         cat->state = state_array[cat->work_var / STOP_RATE] - 1 +
            CAT_STOP_SEQ;
         al_cat_reinit(cat);
      }
      else
         cat->sub_state = CAT_ROOT_INDEX;
   }
}

/* * * * *
*
*  void cat_hit_floor(PART *cat);
*
* * * * */
void cat_hit_floor(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,3,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define FLOOR_RATE      2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_HIT_FLOOR,1,0);
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
		cat->old_scrn_loc.x = cat->scrn_loc.x;
		cat->old_scrn_loc.y = cat->scrn_loc.y;
   }

   if (!(++cat->work_var % FLOOR_RATE))
   {
      if (cat->work_var < NUM_STATES * FLOOR_RATE)
      {
         cat->state = state_array[cat->work_var / FLOOR_RATE] - 1 +
            CAT_HIT_FLOOR_SEQ;
         al_cat_reinit(cat);
      }
      else
         cat->sub_state = CAT_SHAKE_INDEX;
   }
}


/* * * * *
*
*  void cat_hit_ceiling(PART *cat);
*
* * * * */
void cat_hit_ceiling(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define CEILING_RATE    2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_HIT_CEILING,1,0);

      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }

   if (!(++cat->work_var % CEILING_RATE))
   {
      if (cat->work_var < NUM_STATES * CEILING_RATE)
      {
         cat->state = state_array[cat->work_var / CEILING_RATE] - 1 +
            CAT_HIT_CEILING_SEQ;
        al_cat_reinit(cat);
      }
      else
         cat->sub_state = CAT_SHAKE_INDEX;
   }
}


/* * * * *
*
*  void cat_hit_left_wall(PART *cat);
*
* * * * */
void cat_hit_left_wall(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1,1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define LEFT_WALL_RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_HIT_WALL,1,0);

      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }

   if (!(++cat->work_var % LEFT_WALL_RATE))
   {
      if (cat->work_var < NUM_STATES * LEFT_WALL_RATE)
      {
         cat->state = state_array[cat->work_var / LEFT_WALL_RATE] - 1 +
            CAT_HIT_LEFT_WALL_SEQ;
        al_cat_reinit(cat);
      }
      else
         cat->sub_state = CAT_ROOT_INDEX;
   }
}


/* * * * *
*
*  void cat_hit_right_wall(PART *cat);
*
* * * * */
void cat_hit_right_wall(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1,1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define RIGHT_WALL_RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_HIT_WALL,1,0);

      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }

   if (!(++cat->work_var % RIGHT_WALL_RATE))
   {
      if (cat->work_var < NUM_STATES * RIGHT_WALL_RATE)
      {
         cat->state = state_array[cat->work_var / RIGHT_WALL_RATE] - 1 +
            CAT_HIT_RIGHT_WALL_SEQ;
        al_cat_reinit(cat);
      }
      else
         cat->sub_state = CAT_ROOT_INDEX;
   }
}

/* * * * *
*
*  void cat_slide1(PART *cat);
*
* * * * */
void cat_slide1(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,2,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE1_RATE            1
   
   if (!cat->work_var)
      jtp_sx_play(SX_CAT_SLIDE1,0,0);

   if (!(++cat->work_var % SLIDE1_RATE))
   {
      if (cat->work_var < NUM_STATES * SLIDE1_RATE)
      {
         cat->state = state_array[cat->work_var / SLIDE1_RATE] - 1 +
            CAT_SLIDE1_SEQ;
         al_cat_reinit(cat);

      }
      else
         cat->work_var = 0;
   }
}


/* * * * *
*
*  void cat_slide2(PART *cat);
*
* * * * */
void cat_slide2(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,2,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE2_RATE            1

   if (!cat->work_var)
      jtp_sx_play(SX_CAT_SLIDE2,0,0);

   if (!(++cat->work_var % SLIDE2_RATE))
   {
      if (cat->work_var < NUM_STATES * SLIDE2_RATE)
      {
         cat->state = state_array[cat->work_var / SLIDE2_RATE] - 1 +
            CAT_SLIDE2_SEQ;
         al_cat_reinit(cat);
      }
      else
         cat->work_var = 0;
   }
}


/* * * * *
*
*  void cat_slide3(PART *cat);
*
* * * * */
void cat_slide3(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,2,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE3_RATE            1

   if (!cat->work_var)
      jtp_sx_play(SX_CAT_SLIDE3,0,0);

   if (!(++cat->work_var % SLIDE3_RATE))
   {
      if (cat->work_var < NUM_STATES * SLIDE3_RATE)
      {
         cat->state = state_array[cat->work_var / SLIDE3_RATE] - 1 +
            CAT_SLIDE3_SEQ;
         al_cat_reinit(cat);
      }
      else
         cat->work_var = 0;
   }
}


/* * * * *
*
*  void cat_slide4(PART *cat);
*
* * * * */
void cat_slide4(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,2,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SLIDE4_RATE            1

   if (!cat->work_var)
      jtp_sx_play(SX_CAT_SLIDE4,0,0);

   if (!(++cat->work_var % SLIDE4_RATE))
   {
      if (cat->work_var < NUM_STATES * SLIDE4_RATE)
      {
         cat->state = state_array[cat->work_var / SLIDE4_RATE] - 1 +
            CAT_SLIDE4_SEQ;
         al_cat_reinit(cat);
      }
      else
         cat->work_var = 0;
   }
}

/* * * * *
*
*  void cat_pin1(PART *cat);
*
* * * * */
void cat_pin1(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1,1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PIN1_RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_PIN,1,0);

      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
      character_from_move_to_static(cat);
   }

   if (!(++cat->work_var % PIN1_RATE))
   {
      if (cat->work_var < NUM_STATES * PIN1_RATE)
      {
         cat->state = state_array[cat->work_var / PIN1_RATE] - 1 +
            CAT_PIN1_SEQ;

         /* check if the cat is in the launch frame */
         if (cat->state == CAT_PIN1_SEQ + 1)
         {
            character_from_static_to_move(cat);
            cat->speed.y = -SIXTEEN_PIX;
         }
         al_cat_reinit(cat);
      }
      else
      {
         /* Give the cat an initial negative vertical velocity */
         if (cat->work_var == NUM_STATES * PIN1_RATE)
            cat->speed.y = -(SIXTEEN_PIX + EIGHT_PIX);

         /* check if the cat has begun to fall */
         if (cat->speed.y > CAT_FALLING)
            cat->sub_state = CAT_FLAIL_INDEX;
      }
   }
}


/* * * * *
*
*  void cat_pin2(PART *cat);
*
* * * * */
void cat_pin2(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,2,3,2,3,2,3,2,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PIN2_RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_PIN,1,0);
      character_from_move_to_static(cat);
   }
   
   /* check if the cats velocity needs to be reset in a very special case */
   /* NOTE: This is horible coding but it is already September 13. */
   if ((cat->work_var == 4 * PIN2_RATE) &&
      (cat->state == CAT_PIN2_SEQ + 1) &&
      (cat->old_state == CAT_PIN2_SEQ))
      cat->speed.y = 0;

   /* check if the cat has begun to fall */
   if (cat->speed.y > CAT_FALL_THRESHOLD2)
      cat->sub_state = CAT_FLAIL_INDEX;

   if (!(++cat->work_var % PIN2_RATE))
   {
      if (cat->work_var < NUM_STATES * PIN2_RATE)
      {
         /* animate the cat */
         cat->state = state_array[cat->work_var / PIN2_RATE] - 1 +
            CAT_PIN2_SEQ;

         /* check if the cat should start to fall */
         if ((cat->state == CAT_PIN2_SEQ + 1) &&
            (cat->old_state == CAT_PIN2_SEQ))
         {
            character_from_static_to_move(cat);

            /* This aligns the tops of the shape */
            cat->speed.y = short_to_pix(cat->old_size.y - cat->size.y);
         }

         al_cat_reinit(cat);
      }
   }
}

/* * * * *
*
*  void cat_pin3(PART *cat);
*
* * * * */
void cat_pin3(PART *cat)
{
   #define PIN3_FLY     3
   static const char far state_array[] =
   {
      1,1,1,1,1,2,2,2,2,PIN3_FLY,PIN3_FLY+1
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PIN3_RATE            2

   short sign;

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_PIN,1,0);
    
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
      character_from_move_to_static(cat);
   }
   
   if (!(++cat->work_var % PIN3_RATE))
   {
      if (cat->work_var < (NUM_STATES - 2) * PIN3_RATE)
      {
         cat->state = state_array[cat->work_var / PIN3_RATE] - 1 +
            CAT_PIN3_SEQ;
         al_cat_reinit(cat);

         if (cat->state == 1 + CAT_PIN3_SEQ)
            jtp_sx_play(SX_CAT_PIN3_YELL,3,0);
      }
      else
      {
         /* remove cat from static list */
         if (cat->work_var == (NUM_STATES - 2) * PIN1_RATE)
         {
            character_from_static_to_move(cat);
            
            /* check orientation of the cat */
            if (cat->flags2 & F2_FLIP_H_DRAW)
               sign = -1;
            else
               sign = 1;

            /* set the initial launch velocity */
            cat->speed.x = sign * SIX_PIX;
            cat->speed.y = -SIX_PIX;
         }

         /* animate the cat flying in the air */
         if (cat->state == CAT_PIN3_SEQ + PIN3_FLY - 1)
            cat->state = CAT_PIN3_SEQ + PIN3_FLY;
         else
            cat->state = CAT_PIN3_SEQ + PIN3_FLY - 1;
      }
   }
}

/* * * * *
*
*  void cat_vac1(PART *cat);
*
* * * * */
void cat_vac1(PART *cat)
{          
   static const char far state_array[] =
   {
      1,1,1,2,2,1,1,2,2,1,1,2,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define VAC1_RATE        2

   if (!(++cat->work_var % VAC1_RATE))
   {
      if (cat->work_var < NUM_STATES * VAC1_RATE)
      {
         cat->state = state_array[cat->work_var / VAC1_RATE] - 1 +
            CAT_VAC1_SEQ;
         al_cat_reinit(cat);
      }
      else
         cat->work_var = 0;
   }
   cat->sub_state = CAT_ROOT_INDEX;
}

/* * * * *
*
*  void cat_vac2(PART *cat);
*
* * * * */
void cat_vac2(PART *cat)
{
   #define CAT_VAC2_NUM_OFFSETS  32
   #define VAC2_RATE        2

   /* offset coordinates */
   static signed const char far cat_vac2_os[CAT_VAC2_NUM_OFFSETS][3] =
      {{0,2,1},{0,-2,0},{0,2,1},{0,-2,0},{0,2,1},
      {0,-2,0},{0,2,1},{6,-2,2},{-1,-1,3},{1,1,2},{-1,-1,3},
      {1,1,2},{-1,-1,3},{1,1,2},{-1,-1,3},{9,1,4},{0,1,5},
      {0,-1,4},{0,1,5},{0,-1,4},{0,1,5},{0,-1,4},{0,1,5},
      {12,-1,6},{-1,-1,7},{1,1,6},{-1,-1,7},{1,1,6},{-1,-1,7},
      {1,1,6},{-1,-1,7}};

   short sign,index;

   if (!(++cat->work_var % VAC2_RATE))
   {
      index = cat->work_var / VAC2_RATE;
      
      /* check if the cat is not falling */
      if (cat->speed.y <= CAT_FALLING)
      {
         /* check surroundings */
         /* NOTE: the forced index on -1 ensures that the cat will stop  */
         /* walking */
         if (cat_observation(cat) == -1)
            cat->sub_state = CAT_ROOT_INDEX;

         /* check if the animation should loop */
         if (index >= CAT_VAC2_NUM_OFFSETS)
            cat->work_var = index = 0;

         /* animate the cat walking under the vacuum */
         cat->state = cat_vac2_os[index][2] + CAT_VAC2_SEQ;

         /* check for orientation */
         if (cat->flags2 & F2_FLIP_H_DRAW)
            sign = -1;
         else
            sign = 1;
   
         /* move the cat according to the offsets */
         cat->speed.x = sign * short_to_pix(cat_vac2_os[index][0]);
         al_cat_reinit(cat);
      }
      else
         cat->sub_state = CAT_FLAIL_INDEX;
   }
}

/* * * * *
*
*  void cat_vac3(PART *cat);
*
* * * * */
#pragma argsused
void cat_vac3(PART *cat)
{
   cat->sub_state = CAT_ROOT_INDEX;
}


/* * * * *
*
*  void cat_piano(PART *cat);
*
*  This function assume that the specified cat is in the correct position.
*
* * * * */
void cat_piano(PART *cat)
{
   PART *piano;
   short index;

   /* offset coordinates */
   static signed const char far cat_piano_os[][3] =
   {
      {25,10,1},{25,10,1},{28,-12,2},{33,-14,2},{28,-12,3},{35,-13,3},
      {42,-14,3},{56,-19,4},{55,-21,4},{39,-26,4},{28,-21,5},{10,-22,5},
      {4,-18,5},{3,-30,2},{13,-30,2},{28,-22,3},{40,-20,3},{68,-23,4},
      {64,-26,4},{43,-23,5},{33,-28,2},{33,-28,2},{33,-28,2},{33,-28,2},
      {33,-28,2},{33,-28,2},{29,-23,5},{12,-28,2},{13,-30,2},{13,-30,2},
      {28,-22,3},{40,-20,3},{68,-23,4},{64,-26,4},{43,-23,5},{29,-23,5},
      {12,-28,2},{19,-26,2},{27,-21,3},{38,-13,3},{41,-8,3}
   };
   #define CAT_PIANO_NUM_OFFSETS    (sizeof(cat_piano_os)/(sizeof(char)*3))
   #define PIANO_RATE               2
   #define PIANO_REST               7

   /* check if the link is ok */
   if (((piano = cat->toon_link) == 0) || (piano->type != PT_PIANO))
   {
      cat->sub_state = CAT_ROOT_INDEX;
      character_from_static_to_move(cat);
      return;
   }

   /* check if the piano is ready for the cat piano animation */
   if (piano->state == PIANO_REST)
   {
      index = ++cat->work_var / PIANO_RATE;

      /* check if the cat should animate */
      if (!(cat->work_var % PIANO_RATE))
      {
         if (index < CAT_PIANO_NUM_OFFSETS)
            cat->state = cat_piano_os[index][2] + CAT_PIANO_SEQ - 1;
         else
         {
            kill_character(cat);
            return;
         }

         /* reposition the cat to align with the piano */
         cat->loc.x = cat->scrn_loc.x =
            piano->scrn_loc.x + cat_piano_os[index][0] - 18;
         cat->loc.y = cat->scrn_loc.y =
            piano->scrn_loc.y + cat_piano_os[index][1] + 20;
         cat->loc.x <<= SCALE_SHIFT;
         cat->loc.y <<= SCALE_SHIFT;

         al_cat_reinit(cat);

         /* force the redraw of the piano  */
         /* NOTE: This may not be very efficient--ask RICHR */
         part_to_er(piano,1|2);
      }
   }
   else
   {
      if (!cat->work_var)
      {
         /* reposition the cat to align with the piano */
         cat->loc.y = cat->old_scrn_loc.y = cat->scrn_loc.y += 18; 
         cat->loc.y <<= SCALE_SHIFT;
         al_cat_reinit(cat);
         cat->work_var = 1;
      }
   }

   /* make the border zero through out the sequence */
   cat->border = 0;
}

/* * * * *
*
*  void cat_gum(PART *cat);
*
* * * * */
void cat_gum(PART *cat)
{
   PART *link;
   P_PART_ELEMENTS elements;
   short new_acel;

   static const char far state_array[] =
   {
      1,1,1,1,1,1,1,1,1,1,1,2,2,3,3,3,3,3,4,5,6,7,8,9,10,11,12,13,13,13,13,13,
      14,13,14,13,14,13,14,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define GUM_RATE        2
   #define FLOAT_ACEL      -TWO_PIX

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;

      /* turn off the speed of the gum */
      if (((link = cat->toon_link) != 0) && (link->type == PT_GUM))
         link->speed.x = link->speed.y = 0;
   }

   if (!(++cat->work_var % GUM_RATE))
   {
      if (cat->work_var < NUM_STATES * GUM_RATE)
      {
         /* animate the cat eating the gum */
         cat->state = state_array[cat->work_var / GUM_RATE] - 1 + CAT_GUM_SEQ;
         al_cat_reinit(cat);

         /* check if the cat should be repositioned up */
         if (cat->state == CAT_GUM_SEQ + 22)
            cat->speed.y = -short_to_pix(40);

         /* check if the cat should begin to accelerate upwards */
         if (cat->state > CAT_GUM_SEQ + 22)
         {
            /* overwrite the adjust_falling function called just prior to this  */
            /* internal */
            elements = &prop[cat->type];
            new_acel = FLOAT_ACEL - elements->acel;
            cat->speed.y += new_acel;
            check_term_velocity(cat);
            cat->force = smuls(abs(cat->speed.x)+abs(cat->speed.y),cat->mass);
         }

         /* kill the pack of gum on the appropriate frame */
         if (  (cat->state == 2 + CAT_GUM_SEQ)
            && (cat->old_state == 1 + CAT_GUM_SEQ)
            && ((link = cat->toon_link) != 0)
            && (link->type == PT_GUM))
         {
            kill_character(link);
            cat->toon_link = 0;
         }

         if (  (cat->state == 2 + CAT_GUM_SEQ)
            && (cat->old_state == 1 + CAT_GUM_SEQ))
            jtp_sx_play(SX_CAT_GUM_GRAB,2,0);
         if (cat->state == 11 + CAT_GUM_SEQ)
            jtp_sx_play(SX_CAT_GUM_SWALLOW,2,0);
         if (  (cat->state == 13 + CAT_GUM_SEQ)
            && (cat->old_state == 12 + CAT_GUM_SEQ))
            jtp_sx_play(SX_CAT_GUM_CHEW,2,1);
         if (  (cat->state == 14 + CAT_GUM_SEQ)
            && (cat->old_state == 13 + CAT_GUM_SEQ))
            jtp_sx_play(SX_CAT_GUM_BLOW,2,1);
      }
      else
      {
         /* overwrite the adjust_falling function called just prior to this  */
         /* internal */
         elements = &prop[cat->type];
         new_acel = FLOAT_ACEL - elements->acel;
         cat->speed.y += new_acel;
         check_term_velocity(cat);
         cat->force = smuls(abs(cat->speed.x)+abs(cat->speed.y), cat->mass);
      }
   }
   else
   {
      /* check if the cat should stop its upward velocity */
      if (cat->state == CAT_GUM_SEQ + 22)
         cat->speed.y = 0;
   }
}

/* * * * *
*
*  void cat_lunch(PART *cat);
*
* * * * */
void cat_lunch(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,3,4,5,6,7,7,7,7,7,
      8,8,8,8,8,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,
      12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,
      24,24,25,25,25,25,25,26,26,26,26,26,26,27,28,29,30,31,31,31,31,31,31,31,
      31,31,31,31,31,31,31,31,32,32,32,32,32,33,33,33,33,33,33,33,33,33,33,33,
      33,33,33,33,33,33,33,33,33,34,34,34,34,34,34,35,35,36,37,38,38,38,38,38,
      38,39,39,39,39,39,39,40,41,42,42,42,42,42,43,43,43,44,44,45,45,47,46,47,
      46,47,46,47,46,47,46,47,48,46,48,47,46,47,46,47,48,46,48,47,46,48,49,49,
      50,50,51,51,56,56,56,56,56,56,52,52,52,52,52,52,53,53,53,54,54,54,55,
      55,55,9,9,10,10,6,6,5,5,4,4,3,3,2,2,1,1
   };
   #define LUNCH_NUM_STATES  (sizeof(state_array)/sizeof(char))

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }
   
   if (++cat->work_var < LUNCH_NUM_STATES)
   {
      cat->state = state_array[cat->work_var] - 1 + CAT_LUNCH_SEQ;
      al_cat_reinit(cat);
      
      if (cat->state == CAT_LUNCH_SEQ)
         jtp_sx_play(SX_CAT_LUNCH_PAIL_OUT,3,0);
      if (  (cat->state == 7 + CAT_LUNCH_SEQ)
         && (cat->old_state == 6 + CAT_LUNCH_SEQ))
         jtp_sx_play(SX_CAT_LUNCH_PAIL_DOWN,3,0);
      if (  (cat->state == 10 + CAT_LUNCH_SEQ)
         && (cat->old_state == 9 + CAT_LUNCH_SEQ))
         jtp_sx_play(SX_CAT_LUNCH_LUNCH_POP,3,0);
      if (cat->state == 17 + CAT_LUNCH_SEQ)
         jtp_sx_play(SX_CAT_LUNCH_FALL_DOWN,3,0);
      if (cat->state == 22 + CAT_LUNCH_SEQ)
         jtp_sx_play(SX_CAT_LUNCH_CRASH,3,0);
      if (  (cat->state == 32 + CAT_LUNCH_SEQ)
         && (cat->old_state == 31 + CAT_LUNCH_SEQ))
         jtp_sx_play(SX_CAT_LUNCH_SLURP_TEA,3,0);
      if (cat->state == 45 + CAT_LUNCH_SEQ)
         jtp_sx_play(SX_CAT_LUNCH_CHEW,3,0);
      if (  (cat->state == 51 + CAT_LUNCH_SEQ)
         && (cat->old_state == 55 + CAT_LUNCH_SEQ))
         jtp_sx_play(SX_CAT_LUNCH_KICK,3,0);
   }
   else
   {
      /* force the preempt of the sequence */
      cat->toon_state = cat->sub_state = CAT_ROOT_INDEX;
      cat->state = CAT_ROOT_SEQ;
      cat->work_var = 0;
   }
}

/* * * * *
*
*  void cat_tunnel(PART *cat);
*
* * * * */
void cat_tunnel(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,2,3,4,5,4,5,4,5,4,5,4,5,4,5,4,5,4,5,6,6,6,6,6,6,7,8,9,
      10,9,10,9,10,9,10,9,10,9,10,9,11,12,13,14,15,16,17,17,17,
      17,17,17,17,17,18,19,20,21,22,22,22,22,22,23,24,23,24,23,24,23,
      25,26,27,28,27,28,27,28,27,28,27,28,27,28,29,30,31,32,33,34,35,36
   };
   #define TUNNEL_NUM_STATES    (sizeof(state_array)/sizeof(char))
   #define COMING_OUT_STATE     71
   #define TUNNEL_RATE          2
   #define TUNNEL_DELAY         1
   #define TUNNEL_REST          20


   short index;
   PART *link;

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
      character_from_move_to_static(cat);

      /* check to see that the link is still ok */
      if (((link = cat->toon_link) != 0) && (link->type == PT_TUNNEL))
      {
         /* roughly calculate the distance between the tunnels and weight it */
         /* to fit the animation timing. */
         /* NOTE: belt_size is doubling for a memory field here. */
         cat->belt_size =
            (abs(link->scrn_loc.x-link->toon_link->scrn_loc.x)+
            abs(link->scrn_loc.y - link->toon_link->scrn_loc.y)) >>
            TUNNEL_DELAY;
      }
   }
   
   cat->work_var++;
   index = cat->work_var / TUNNEL_RATE;

   /* check to see if the cat should delay in the tunnel */
   if (index == COMING_OUT_STATE)
   {
      /* check the length in the delay */
      if (cat->belt_size)
      {
         /* force the index to be correct */
         cat->work_var = COMING_OUT_STATE * TUNNEL_RATE;

         cat->belt_size--;
         
         /* reposition the cat off the screen while the cat is delaying in */
         /* the tunnel */
         cat->loc.x =
            cat->loc.y =
            cat->old_scrn_loc.x = 
            cat->old_scrn_loc.y = 
            cat->scrn_loc.x = 
            cat->scrn_loc.y = 1000;
         cat->loc.x <<= SCALE_SHIFT;
         cat->loc.y <<= SCALE_SHIFT;

         /* force woman scream in tunnel */
         if (  (cat->belt_size == 35)
            || (cat->belt_size == 70))
            cat_tunnel_crash_sx();
      }
      else
      {
         /* force the index to be correct */
         cat->work_var = (COMING_OUT_STATE + 1) * TUNNEL_RATE;

         /* check to see that the link is still ok */
         if (((link = cat->toon_link) != 0) && (link->type == PT_TUNNEL))
         {
            /* reposition the cat around the exit tunnel */
            link = link->toon_link;
            if (cat->flags2 & F2_FLIP_H_DRAW)
               cat->loc.x = cat->old_scrn_loc.x = cat->scrn_loc.x =
                  link->scrn_loc.x - 2;
            else
               cat->loc.x = cat->old_scrn_loc.x = cat->scrn_loc.x =
                  link->scrn_loc.x + 10;

            cat->loc.y = cat->old_scrn_loc.y = cat->scrn_loc.y =
               link->scrn_loc.y + 12;

            cat->loc.x <<= SCALE_SHIFT;
            cat->loc.y <<= SCALE_SHIFT;
         }
      }
   }

   if (!(cat->work_var % TUNNEL_RATE))
   {
      if (index < TUNNEL_NUM_STATES)
      {
         cat->state = state_array[index]  - 1 + CAT_TUNNEL_SEQ;
         al_cat_reinit(cat);

         if (  (cat->state == 3 + CAT_TUNNEL_SEQ)
            && (cat->old_state == 2 + CAT_TUNNEL_SEQ))
            jtp_sx_play(SX_CAT_TUNNEL_POCKET,3,0);
         if (cat->state == 7 + CAT_TUNNEL_SEQ)
            jtp_sx_play(SX_CAT_TUNNEL_MATCH,3,0);
         if (cat->state == 10 + CAT_TUNNEL_SEQ)
            jtp_sx_play(SX_CAT_TUNNEL_POOF,3,0);
         if (cat->state == 17 + CAT_TUNNEL_SEQ)
            jtp_sx_play(SX_CAT_TUNNEL_TOSS,3,0);
         if (cat->state == 22 + CAT_TUNNEL_SEQ)
            jtp_sx_play(SX_CAT_TUNNEL_SQUEEZE,3,0);
         if (  (cat->state == 24 + CAT_TUNNEL_SEQ)
            && (cat->old_state == 22 + CAT_TUNNEL_SEQ))
            jtp_sx_play(SX_CAT_TUNNEL_POP1,3,0);
         if (cat->state == 26 + CAT_TUNNEL_SEQ)
            jtp_sx_play(SX_CAT_TUNNEL_OUT,3,0);
         if (cat->state == 28 + CAT_TUNNEL_SEQ)
            jtp_sx_play(SX_CAT_TUNNEL_POP2,3,0);
         if (cat->state == 31 + CAT_TUNNEL_SEQ)
            jtp_sx_play(SX_CAT_TUNNEL_HIT,3,0);
      }
      else
      {
         character_from_static_to_move(cat);
         cat->sub_state = cat->toon_state = CAT_WALK_INDEX;
         cat->state = CAT_WALK_SEQ;
         cat->work_var = 0;
         cat->toon_link = 0;

         /* set up tunnel delay */
         cat->work_var1 = (CAT_TUNNEL_INDEX << CAT_SHIFT) | TUNNEL_REST;
      }
   }
}

/* * * * *
*
*  void cat_pencil1(PART *cat);
*
* * * * */
void cat_pencil1(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1,2,2,2,2,2,3
   };
   #define NUM_STATES               (sizeof(state_array)/sizeof(char))
   #define PENCIL1_SLIDE_SPEED      SIXTEEN_PIX
   #define PENCIL1_MIN_DISTANCE     80
   #define PENCIL1_DIST_X           600

   short index;
   short mouse_mid_x, cat_mid_x;
   PART *pptr,*mouse,*link;

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;

      /* observe the surroundings to see if a mouse is near */
      tn_query_dist(cat,F1_MOVE_L,-PENCIL1_DIST_X,0,
         (PENCIL1_DIST_X<<1)+cat->size.x,cat->size.y);

      pptr = cat->qptr;
      mouse = 0;
      while (pptr)
      {
         /* check if the pptr part is a cat */
         if ((pptr->type == PT_SID_MOUSE) && (abs(pptr->speed.y) < ONE_PIX))
         {
            mouse = pptr;
            pptr = 0;
         }
         else
            pptr = pptr->qptr;
      }

      /* check if a mouse was see. If so set up the jump parameters */
      if (mouse)
      {
         /* check to see that the link is still ok */
         if (((link = cat->toon_link) != 0) && (link->type == PT_PENCIL))
            /* This gets rid of the pencil part on the screen */
            kill_character(link);

         /* link the mouse to the cat */
         cat->toon_link = mouse;
         
         /* force the mouse to stay in one position. */
         mouse->sub_state = mouse->toon_state = SID_BRONX_INDEX;
         mouse->state = SID_BRONX_SEQ;
         mouse->speed.x = mouse->work_var = 0;

         /* orient the mouse to face the cat */
         if (mouse->scrn_loc.x > cat->scrn_loc.x)
         {
            if (mouse->flags2 & F2_FLIP_H_DRAW)
               sid_flip(mouse, F2_FLIP_H_DRAW);
         }
         else
         {
            if (!(mouse->flags2 & F2_FLIP_H_DRAW))
               sid_flip(mouse, F2_FLIP_H_DRAW);
         }

         /* orient the cat to jump at the mouse */
         if (cat->scrn_loc.x < mouse->scrn_loc.x)
         {
            if (cat->flags2 & F2_FLIP_H_DRAW)
               cat_flip(cat, F2_FLIP_H_DRAW);
         }
         else
         {
            if (!(cat->flags2 & F2_FLIP_H_DRAW))
               cat_flip(cat, F2_FLIP_H_DRAW);
         }
      }
      else
      {
         /* overwrite the current sequence. */
         cat->sub_state = cat->toon_state = CAT_ROOT_INDEX;
         cat->state = CAT_ROOT_SEQ;
         cat->work_var = 0;
         return;
      }
   }

   ++cat->work_var;
   index = cat->work_var;

   /* check if the cat is still animating */
   if (index < NUM_STATES)
   {
      /* animate the cat */
      cat->state = state_array[index] - 1 + CAT_PENCIL1_SEQ;
      al_cat_reinit(cat);

      if (cat->state == 2 + CAT_PENCIL1_SEQ)
         jtp_sx_play(SX_CAT_PENCIL_PICKUP,2,0);
   }
   else
   {
      /* check the toon link  */
      if (  ((mouse = cat->toon_link) != 0)
         && (mouse->type == PT_SID_MOUSE))
      {
         mouse_mid_x = mouse->scrn_loc.x + (mouse->base_size.x>>1);
         cat_mid_x = cat->scrn_loc.x + (cat->base_size.x>>1);
         
         /* check if the distance between the cat and the mouse is too  */
         /* large to go into the next cat pencil sequence. */
         if (abs(cat_mid_x - mouse_mid_x) > PENCIL1_MIN_DISTANCE)
         {
            /* check if the mouse is on the left of the cat */
            /* if the artists get me the supershape information on how to */
            /* make this animation a little smoother, it will go here. */
            if (mouse_mid_x < cat_mid_x)
               cat->speed.x = -PENCIL1_SLIDE_SPEED;
            else
               cat->speed.x = PENCIL1_SLIDE_SPEED;

            if (!(cat->work_var % 2))
               cat->loc.y = cat->scrn_loc.y -= 8;
            else
               cat->loc.y = cat->scrn_loc.y += 8;
            cat->loc.y <<= SCALE_SHIFT;
         }
         else
         {
            /* reset the screen location from last jump */
            if (cat->work_var % 2)
            {
               cat->loc.y = cat->scrn_loc.y += 8;
               cat->loc.y <<= SCALE_SHIFT;
            }

            cat->sub_state = CAT_PENCIL2_INDEX;
            cat->speed.x = cat->speed.y = 0;
         }
      }
      else
      {

         /* overwrite the current sequence. */
         cat->sub_state = cat->toon_state = CAT_ROOT_INDEX;
         cat->state = CAT_ROOT_SEQ;
         cat->work_var = 0;
         return;
      }
   }
}

/* * * * *
*
*  void cat_pencil2(PART *cat);
*
* * * * */
void cat_pencil2(PART *cat)
{
   static const char far state_array[] =
   {
      1,2,3,4,5,6,7,8,9,10,11,12,10,4,5,6,7,8,9,10,11,12,10,4,5,6,7,8,
      9,10,11,12
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   PART *link;
   short index;

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* check if the link is still ok and that the mouse is in position */
      if (((link = cat->toon_link) != 0) && (link->type == PT_SID_MOUSE) &&
         (link->scrn_loc.y > cat->scrn_loc.y) &&
         (link->scrn_loc.y < cat->scrn_loc.y + 20))
      {
         /* NOTE: The link is not actually destroyed here. In fact, the mouse */
         /* will be resurrected when it needs to fall off the screen. */
         kill_character(link);
         character_from_move_to_static(cat);
      }
      else
      {
         /* overwrite the current sequence. */
         cat->sub_state = cat->toon_state = CAT_ROOT_INDEX;
         cat->state = CAT_ROOT_SEQ;
         cat->work_var = 0;
         return;
      }
   }

   ++cat->work_var;
   index = cat->work_var;

   /* check if the cat is still animating */
   if (index < NUM_STATES)
   {
      /* animate the cat */
      cat->state = state_array[index] - 1 + CAT_PENCIL2_SEQ;
      al_cat_reinit(cat);

      if (cat->state == 3 + CAT_PENCIL2_SEQ)
         jtp_sx_play(SX_CAT_PENCIL_ERASE,2,0);
   }
   else
   {
      character_from_static_to_move(cat);
      cat->sub_state = CAT_PENCIL4_INDEX;

      /* resurrect the mouse without a head */
      if (((link = cat->toon_link) != 0) && (link->type == PT_SID_MOUSE))
      {
         link->flags2 &= (F2_INACTIVE^0xffff);
         link->sub_state = SID_HEADLESS_INDEX;
         
         /* reposition relative to the cat */
         link->loc.x = link->old_old_scrn_loc.x = link->old_scrn_loc.x =
            link->scrn_loc.x = cat->scrn_loc.x;
         link->loc.y = link->old_old_scrn_loc.y = link->old_scrn_loc.y =
            link->scrn_loc.y = cat->scrn_loc.y + 15;
         link->loc.x <<= SCALE_SHIFT;
         link->loc.y <<= SCALE_SHIFT;
      }
   }
}

/* * * * *
*
*  void cat_pencil4(PART *cat);
*
* * * * */
void cat_pencil4(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,2,3,4,5,6,7
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define PENCIL4_RATE    2

   if (!cat->work_var)
      jtp_sx_play(SX_CAT_PENCIL_THROW,2,1);

   if (!(++cat->work_var % PENCIL4_RATE))
   {
      if (cat->work_var < NUM_STATES * PENCIL4_RATE)
      {
         cat->state = state_array[cat->work_var / PENCIL4_RATE] - 1 +
            CAT_PENCIL4_SEQ;
         al_cat_reinit(cat);
      }
      else
      {
         cat->sub_state = cat->toon_state = CAT_ROOT_INDEX;
         cat->state = CAT_ROOT_SEQ;
      }
   }
}

/* * * * *
*
*  void cat_butt(PART *cat);
*
* * * * */
void cat_butt(PART *cat)
{
   static const char far state_array[] =
   {
      1,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2,1,1,2,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_BUTT,2,0);

      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }
   
   if (!(++cat->work_var % RATE))
   {
      if (cat->work_var < NUM_STATES * RATE)
      {
         cat->state = state_array[cat->work_var / RATE] - 1 +
            CAT_BUTT_SEQ;
         al_cat_reinit(cat);
         
         if (  (cat->state == 1 + CAT_BUTT_SEQ)
            && (cat->old_state == 0 + CAT_BUTT_SEQ))
            jtp_sx_play(SX_CAT_BUTT,2,0);
      }
      else
         cat->sub_state = CAT_ROOT_INDEX;
   }
}

/* * * * *
*
*  void cat_fish(PART *cat);
*
* * * * */
void cat_fish(PART *cat)
{
   PART *link;

   static const char far state_array[] =
   {
      1,1,1,1,1,1,1,1,1,1,2,2,3,3,3,4,4,4,5,5,5,6,6,6,6,6,7,7,7,7,7,7,7,7,7,
      8,8,8,8,8,9,9,9,9,9,10,10,10,10,10,10,11,11,12,12,13,13,14,14,
      15,15,16,16
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   if (++cat->work_var < NUM_STATES)
   {
      cat->state = state_array[cat->work_var] - 1 + CAT_FISH_SEQ;
      al_cat_reinit(cat);

      /* kill the fish on the appropriate frame */
      if ((cat->state == 2 + CAT_FISH_SEQ) &&
         (cat->old_state == 1 + CAT_FISH_SEQ))
      {
         if (((link = cat->toon_link) != 0) && (link->type == PT_FISH))
         {
            kill_character(link);
            cat->toon_link = 0;
            cat->speed.x = 0;
         }
      }

      if (  (cat->state == 5 + CAT_FISH_SEQ)
         && (cat->old_state == 4 + CAT_FISH_SEQ))
         jtp_sx_play(SX_CAT_FISH_GULP,1,0);
      if (cat->state == 8 + CAT_FISH_SEQ)
         jtp_sx_play(SX_CAT_FISH_PULL,1,0);
   }
   else
      cat->sub_state = CAT_ROOT_INDEX;
}

/* * * * *
*
*  void cat_hairdryer(PART *cat);
*
* * * * */
void cat_hairdryer(PART *cat)
{
   P_PART_ELEMENTS elements;
   PART *link;

   static const char far state_array[] =
   {
      1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define HAIRDRYER_RATE            2

   if (!(++cat->work_var % HAIRDRYER_RATE))
   {
      if (cat->work_var < NUM_STATES * HAIRDRYER_RATE)
      {
         cat->state = state_array[cat->work_var / HAIRDRYER_RATE] - 1 +
            CAT_HAIRDRYER_SEQ;
         al_cat_reinit(cat);
      }
      else
      {
         /* overwrite the adjust_falling function called just prior to this  */
         /* internal */
         elements = &prop[cat->type];
         cat->speed.y -= elements->acel + (ONE_PIX >> 1);
         check_term_velocity(cat);
         cat->force = smuls(abs(cat->speed.x)+abs(cat->speed.y),
            cat->mass);

         /* perturb the cat just a little to look like the cat is a balloon. */
         if (cat->work_var == NUM_STATES * HAIRDRYER_RATE)
         {
            /* check if the link is still o.k. */
            if (((link = cat->toon_link) != 0) && (link->type == PT_HAIRDRYER))
            {
               /* orient the cat to face the hairdryer */
               if (cat->scrn_loc.x < link->scrn_loc.x)
                  cat->speed.x -= TWO_PIX;
               else
                  cat->speed.x += TWO_PIX;
            }
            cat->speed.y -= TWO_PIX;
         }

         /* prevent a wrap around of the animation */
         cat->work_var = (NUM_STATES + 1) * HAIRDRYER_RATE;
      }
   }
   if(cat->work_var < NUM_STATES * HAIRDRYER_RATE)
      cat->sub_state = CAT_ROOT_INDEX;
}

/* * * * *
*
*  void cat_peel(PART *cat);
*
* * * * */
void cat_peel(PART *cat)
{
   static const char far state_array[] =
   {
      1,2,3,4,5,6,7,8,9,9,10,10,11,11,12,12
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   PART *link;

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_PEEL_SLIP,0,0);

      /* check if the link is still o.k. */
      if (((link = cat->toon_link) != 0) && (link->type == PT_BANANA))
      {
         cat->toon_link = 0;
         kill_character(link);
      }
   }
   
   /* kill the original velocity */
   cat->speed.x = cat->speed.y = 0;

   if (++cat->work_var < NUM_STATES)
   {
      cat->state = state_array[cat->work_var] - 1 + CAT_PEEL_SEQ;
      al_cat_reinit(cat);

      if (cat->state == 6 + CAT_PEEL_SEQ)
         jtp_sx_play(SX_CAT_PEEL_HIT,3,1);
   }
   else
      cat->sub_state = CAT_SHAKE_INDEX;
}

/* * * * *
*
*  void cat_banana(PART *cat);
*
* * * * */
void cat_banana(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,2,2,2,2,2,3,3,3,3,4,5,
      6,7,8,9,10,11,12,13,12,13,
      12,13,12,13,12,13,12,13
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define BANANA_RATE     2
   #define KILL_BANANA     1
   #define RELEASE_BANANA  8
   #define SLIP            2
   
   PART *link;

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }

   if (!(++cat->work_var % BANANA_RATE))
   {
      if (cat->work_var < NUM_STATES * BANANA_RATE)
      {
         cat->state = state_array[cat->work_var / BANANA_RATE] - 1 +
            CAT_BANANA_SEQ;
         al_cat_reinit(cat);

         /* check if the original banana should be killed */
         if ((cat->state == KILL_BANANA + CAT_BANANA_SEQ) &&
            (cat->old_state == KILL_BANANA - 1 + CAT_BANANA_SEQ))
         {
            /* check if the link is still o.k. */
            if (((link = cat->toon_link) != 0) && (link->type == PT_BANANA))
               kill_character(link);
         }

         /* check if the banana should be released into the air */
         if ((cat->state == RELEASE_BANANA + CAT_BANANA_SEQ) &&
            (cat->old_state == RELEASE_BANANA - 1 + CAT_BANANA_SEQ))
         {
            /* check if the link is still o.k. */
            if (((link = cat->toon_link) != 0) && (link->type == PT_BANANA))
            {
               cat->toon_link = 0;

               /* resurrect the banana as a peel */
               link->flags2 &= F2_INACTIVE ^ 0xffff;
               link->state = BANANA_PEEL;
               if (cat->flags2 & F2_FLIP_H_DRAW)
               {
                  link->loc.x = link->scrn_loc.x =
                     cat->scrn_loc.x + cat->base_size.x -
                     (cat->size.x + cat->offset.x + 17);
                  link->speed.x = -FOUR_PIX;
               }
               else
               {
                  link->loc.x = link->scrn_loc.x = cat->scrn_loc.x + 45;
                  link->speed.x = FOUR_PIX;
               }

               link->loc.y = link->scrn_loc.y = cat->scrn_loc.y + 8;
               link->speed.y = -FIVE_PIX;
               link->loc.x <<= SCALE_SHIFT;
               link->loc.y <<= SCALE_SHIFT;
               banana_reinit(link);
            }
         }

         /* start sx of banana flying up */
         if (cat->state == 3 + CAT_BANANA_SEQ)
            jtp_sx_play(SX_CAT_BANANA_SQUEEZE,3,0);
         if (cat->state == 10 + CAT_BANANA_SEQ)
            jtp_sx_play(SX_CAT_BANANA_GULP,3,0);
         if (cat->state == 12 + CAT_BANANA_SEQ)
            jtp_sx_play(SX_CAT_BANANA_CHEW,3,0);
      }
      else
      {
         /* force the preemption of the toon state */
         cat->sub_state = cat->toon_state = CAT_ROOT_INDEX;
         cat->state = CAT_ROOT_INDEX;
         cat->work_var = 0;
      }
   }
}

/* * * * *
*
*  void cat_rug(PART *cat);
*
* * * * */
#pragma argsused
void cat_rug(PART *cat)
{
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_RUG,1,0);
      cat->work_var++;
   }
}

/* * * * *
*
*  void cat_gum2(PART *cat);
*
* * * * */
void cat_gum2(PART *cat)
{
   static const char far state_array[] =
   {
      1,2
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define GUM2_RATE            2

   /* align the tops of the cat by forcing the velocities of the borders */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_GUM_POP,2,0);
      cat->speed.y = short_to_pix(40);
   }
   else if (cat->work_var == 1)
      cat->speed.y = 0;

   if (!(++cat->work_var % GUM2_RATE))
   {
      if (cat->work_var < NUM_STATES * GUM2_RATE)
      {
         cat->state = state_array[cat->work_var / GUM2_RATE] - 1 +
            CAT_GUM2_SEQ;
         al_cat_reinit(cat);
      }
   }
}

/* * * * *
*
*  void cat_gum3(PART *cat);
*
* * * * */
void cat_gum3(PART *cat)
{
   static const char far state_array[] =
   {
      1,1,1,1,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,5,5,5,6,6,
      6,7,7,7,8,8,8,8,8,8,8,8,8,8,9,9,8,8,9,9,8,8,9,9,8,8,9,9,10,10,10,10,10,
      11,11,11,11,12,12,12,12,12,12,13,13,13,14,14,15,15,16,16,12,12
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define GUM3_RATE            2

   if (!(++cat->work_var % GUM3_RATE))
   {
      if (cat->work_var < NUM_STATES * GUM3_RATE)
      {
         cat->state = state_array[cat->work_var / GUM3_RATE] - 1 +
            CAT_GUM3_SEQ;
         al_cat_reinit(cat);

         if (cat->state == CAT_GUM3_SEQ)
            jtp_sx_play(SX_CAT_GUM_SPLAT,3,0);
         if (  (cat->state == 3 + CAT_GUM3_SEQ)
            && (cat->old_state == 2 + CAT_GUM3_SEQ))
            jtp_sx_play(SX_CAT_GUM_SLURP,3,0);
         if (  (cat->state == 8 + CAT_GUM3_SEQ)
            && (cat->old_state == 7 + CAT_GUM3_SEQ))
            jtp_sx_play(SX_CAT_GUM_CHEW,3,0);
         if (cat->state == 9 + CAT_GUM3_SEQ)
            jtp_sx_play(SX_CAT_GUM_GULP,3,0);
         if (cat->state == 12 + CAT_GUM3_SEQ)
            jtp_sx_play(SX_CAT_GUM_SLURP,3,0);
      }
      else
         cat->sub_state = CAT_ROOT_INDEX;
   }
}

/* * * * *
*
*  void cat_egg(PART *cat);
*
* * * * */
void cat_egg(PART *cat)
{
   PART *toon_link;

   static const char far state_array[] =
   {
      1,1,2,2,3,3,4,4,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,
      6,6,6,6,7,7,7,7,7,7,7,7,7,7,6,6,6,6,6,6,7,7,7,7,7,7,6,6,
      6,6,6,7,7,7,7,7,6,6,6,6,7,7,7,7,8,8,8,8,9,9,8,9,8,10,11,12,13,
      14,15,16,17,14,17,14,17,14,17,14,17,14,17,14,17,14,17,18,19,18,
      19,18,19,18,20,21,22,21,22,21,22,23,24,25,26,27,26,27,26,27,28,
      28,29,29,28,28,29,29,28,28,29,29,28,28,29,29,28,28,29,29
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      jtp_sx_play(SX_CAT_EGG_CRACK,3,0);

      if (((toon_link = cat->toon_link) != 0) && (toon_link->type == PT_EGG))
      {
         kill_character(toon_link);
         cat->toon_link = 0;
      }
   }
   
   if (++cat->work_var < NUM_STATES)
   {
      cat->state = state_array[cat->work_var] - 1 + CAT_EGG_SEQ;
      al_cat_reinit(cat);

      if (  (cat->state == 6 + CAT_EGG_SEQ)
         && (cat->old_state == 5 + CAT_EGG_SEQ))
         jtp_sx_play(SX_CAT_EGG_MAD,3,0);
      if (cat->state == 9 + CAT_EGG_SEQ)
         jtp_sx_play(SX_CAT_EGG_BURN,3,0);
      if (cat->state == 28 + CAT_EGG_SEQ)
         jtp_sx_play(SX_CAT_EGG_MAD,3,0);
   }
   else
      cat->sub_state = CAT_ROOT_INDEX;
}

/* * * * *
*
*  void cat_pounce(PART *cat);
*
* * * * */
void cat_pounce(PART *cat)
{
   static const char far state_array[] =
   {
      1,2,2,3,3
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define POUNCE_RATE     2
   
   if (!cat->work_var)
      jtp_sx_play(SX_CAT_POUNCE,3,0);

   if (!(++cat->work_var % POUNCE_RATE))
   {
      if (cat->work_var < NUM_STATES * POUNCE_RATE)
      {
         cat->state = state_array[cat->work_var / POUNCE_RATE] - 1 +
            CAT_POUNCE_SEQ;

         /* check if the cat should launch into the air */
         if ((cat->state == CAT_POUNCE_SEQ + 2) &&
            (cat->old_state == CAT_POUNCE_SEQ + 1))
         {
            cat->speed.y = -EIGHT_PIX;
            cat->speed.x = TWO_PIX;
            if (cat->flags2 & F2_FLIP_H_DRAW)
               cat->speed.x *= -1;
         }
         al_cat_reinit(cat);
      }
   }
}

/* * * * *
*
*  void cat_yarn(PART *cat);
*
* * * * */
void cat_yarn(PART *cat)
{
   PART *toon_link;

   static const char far state_array[] =
   {
      1,2,3,1,2,3,1,2,3,1,2,3,
      1,2,3,1,2,3,4,5,6,4,5,6,4,5,6,4,4,4,4,4,5
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define YARN_RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* check if the toon link is still ok. */
      if(((toon_link = cat->toon_link)!=0) && (toon_link->type==PT_YARNBALL))
      {
         kill_character(toon_link);
         cat->toon_link = 0;
      }
   }
   
   if (!(++cat->work_var % YARN_RATE))
   {
      if (cat->work_var < NUM_STATES * YARN_RATE)
      {
         cat->state = state_array[cat->work_var / YARN_RATE] - 1 +
            CAT_YARN_SEQ;
         al_cat_reinit(cat);

         if (cat->state < 3 + CAT_YARN_SEQ)
            cat_fight_sx();
      }
      else
      {
         /* make the eyes wiggle back and forth */
         if (cat->state == 6 - 1 + CAT_YARN_SEQ)
            cat->state = 6 - 1 - 2 + CAT_YARN_SEQ;
         else
            cat->state++;

         cat->work_var = NUM_STATES * YARN_RATE;
      }
   }
}

/* * * * *
*
*  void cat_scratch(PART *cat);
*
* * * * */
void cat_scratch(PART *cat)
{
   static const char far state_array[] =
   {
      1,2,3,4,5,6,1,1,1,1,1,2,3,4,5,6
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define SCRATCH_RATE            2

   if (!(++cat->work_var % SCRATCH_RATE))
   {
      if (cat->work_var < NUM_STATES * SCRATCH_RATE)
      {
         cat->state = state_array[cat->work_var / SCRATCH_RATE] - 1 +
            CAT_SCRATCH_SEQ;
         al_cat_reinit(cat);

         if (  (cat->state == 1 + CAT_SCRATCH_SEQ)
            && (cat->old_state == CAT_SCRATCH_SEQ))
            jtp_sx_play(SX_CAT_SCRATCH,2,0);
      }
      else
      {
         /* check to see if the surrounds are not interesting to the cat */
         if (cat_observation(cat) == -1)
            cat->sub_state = CAT_ROOT_INDEX;
      }
   }
}

#if 0
/* * * * *
*
*  void cat_(PART *cat);
*
* * * * */
void cat_(PART *cat)
{
   static const char far state_array[] =
   {
   };
   #define NUM_STATES      (sizeof(state_array)/sizeof(char))
   #define RATE            2

   /* check for the first time into this sequence */
   if (!cat->work_var)
   {
      /* kill the original velocity */
      cat->speed.x = cat->speed.y = 0;
   }
   
   ++cat->work_var;
   if (!(cat->work_var % RATE))
   {
      if (cat->work_var < NUM_STATES * RATE)
      {
         cat->state = state_array[cat->work_var / RATE] - 1 +
            CAT__SEQ;
         al_cat_reinit(cat);
      }
      else
      {
         cat->sub_state = ;
      }
   }
}
#endif


	
